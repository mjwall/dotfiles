This is jdee.info, produced by makeinfo version 5.2 from jdee.texi.


File: jdee.info,  Node: Top,  Next: User's Guide,  Prev: (dir),  Up: (dir)

The Java Development Environment for Emacs (JDEE)
*************************************************

* Menu:

* User's Guide::
* Developer's Guide::
* Index::

 — The Detailed Node Listing —

User’s Guide

* Introduction::
* Registering and Selecting a JDK::
* Editing Java Source Files::
* Documenting Code::
* Abbreviations::
* Completing Expressions::
* Dynamic Keyword Completion::
* Generating Code::
* Checking Coding Style::
* Compiling Java Programs::
* Building Java Applications::
* Running Java Applications::
* Working with Applets::
* Debugging Applications::
* Specifying Classpaths::
* Using Project Files::
* Displaying Java Documentation::
* Browsing Source Code::
* Searching Source Code::
* Customizing the JDEE::
* Installing a Plugin::

Introduction

* About::
* JDEE Requirements::
* Latest Version::
* Installing the JDEE::
* Reporting bugs::

Registering and Selecting a JDK

* Registering a JDK::
* Selecting a JDK::

Documenting Code

* Inserting Javadoc Comments::
* Generating the Documentation::

Abbreviations

* Keyword Abbreviations::
* Control Flow Abbreviations::

Control Flow Abbreviations

* Left Brace Placement::
* Customizing the Control Flow Templates::
* Adding Your Own Control Flow Templates::
* Enabling Variable Content::
* Disabling the Control Flow Abbreviations::

Completing Expressions

* Completing Method and Field Names::
* Selecting a Completion Method::
* Using Menu-Based Completion::
* Using In-Line Completion::
* Speeding Up Completion::

Dynamic Keyword Completion

* Dynamic Completion Commands::
* Electric Return::

Generating Code

* Generating Import Statements::
* Code Wizards::
* Code Templates::

Generating Import Statements

* Importing Classes::           Generate an import statement for the class at point
* Importing All Classes::       Generate import statements for all classes in the current buffer that need import statements
* Expanding Package Imports::   Expand a package import statement into specific class imports
* Collapsing Class Imports::    Collapse class imports into a package import statement
* Grouping Imports::            Group import statements
* Deleting Unneeded Imports::   Delete superfluous import statements

Code Wizards

* Method Override Wizard::
* Interface Wizard::
* Delegate Wizard::
* Get/Set Wizard::

Code Templates

* Buffer Templates::
* Specifying Boilerplate Text::
* Code Templates Customization Variables::
* Point Templates::
* Customizing Templates::
* Creating Templates::
* Defining a Template and Template Insertion Function::
* Registering Custom Templates::
* Assigning Keys to Templates::

Compiling Java Programs

* Compilation Buffer::
* Specifying a Compiler::
* Compilation Options::

Compilation Options

* Setting Compile Options Interactively::
* Compiler Customization Variables::

Building Java Applications

* Selecting a Build Method::
* Building with Make::
* Building with Ant::

Building with Make

* Make Options::
* Sample Makefile::

Running Java Applications

* Specifying the Application's Main Class::
* Specifying a Startup Directory::
* Setting VM Command-Line Arguments::
* Setting Command-Line Application Arguments::
* Navigating Exception Traces::
* Run Customization Variables::

Working with Applets

* Running Applets::
* Debugging Applets::
* Applet Customization Variables::

Specifying Classpaths

* Setting a Classpath Variable::
* Including Class Libraries::

Using Project Files

* How the JDEE Finds Project Files::
* Project File Contents::
* Creating a Project File::
* Creating Portable Projects::
* Disabling Context Switching::
* Project Hook Functions::

Displaying Java Documentation

* Browsing JDK Documentation::
* Context-Sensitive Class Help::
* Specifying a Browser::

Specifying a Browser

* Using emacs-w3m to Browse Java Doc::

Browsing Source Code

* Classes Index Menu::
* Using the Speedbar::
* Tags::

Classes Index Menu

* Special Index Entries::
* Alphabetizing the Classes Menu::
* Suppressing Method Signatures and Field Types::
* Disabling the Classes Menu::
* Using the Keyboard to Navigate the Classes Menu::

Using the Speedbar

* Package::
* Types::
* Dependencies::
* Updating the Speedbar::

Tags

* Tagging Java Source Code::
* Finding the Definition of a Symbol::

Searching Source Code

* Finding Expressions::
* Finding Symbol Definitions::
* Finding Classes::
* Cross-Referencing Classes::

Finding Expressions

* Using the Minibuffer-Based Find (jdee-find) Command::
* Customizing the Minibuffer-Based Find Command::
* Using the Dialog-Based Find (jdee-find-dlg) Command::

Cross-Referencing Classes

* Configuring the Cross-Referencer::
* Building the Cross-Reference Database::
* Using the Cross-Reference Database::
* Updating the Cross-Reference Database::

Customizing the JDEE

* JDEE Customization Variables::
* Customizing jdee-mode::

JDEE Customization Variables

* Setting a Customization Variable::
* Specifying Paths::
* JDEE Customization Groups::

Customizing jdee-mode

* Customizing Key Bindings::

Developer’s Guide

* JDEE Components::             Describes parts of JDEE
* Creating Plugins::

Creating Plugins

* Plugin Requirements::
* Registering a Plugin::
* Running Java Code from a Plugin::
* Bootstrap File Example::



File: jdee.info,  Node: User's Guide,  Next: Developer's Guide,  Prev: Top,  Up: Top

1 User’s Guide
**************

Welcome to the JDEE User’s Guide.  This guide explains how to use the
JDEE to develop Java applications.  The guide assumes that you are
familiar with Emacs, the Java programming language, and Java development
tools provided by Oracle.

* Menu:

* Introduction::
* Registering and Selecting a JDK::
* Editing Java Source Files::
* Documenting Code::
* Abbreviations::
* Completing Expressions::
* Dynamic Keyword Completion::
* Generating Code::
* Checking Coding Style::
* Compiling Java Programs::
* Building Java Applications::
* Running Java Applications::
* Working with Applets::
* Debugging Applications::
* Specifying Classpaths::
* Using Project Files::
* Displaying Java Documentation::
* Browsing Source Code::
* Searching Source Code::
* Customizing the JDEE::
* Installing a Plugin::


File: jdee.info,  Node: Introduction,  Next: Registering and Selecting a JDK,  Prev: User's Guide,  Up: User's Guide

1.1 Introduction
================

* Menu:

* About::
* JDEE Requirements::
* Latest Version::
* Installing the JDEE::
* Reporting bugs::


File: jdee.info,  Node: About,  Next: JDEE Requirements,  Prev: Introduction,  Up: Introduction

1.1.1 About
-----------

The Java Development Environment for Emacs (JDEE) is an Emacs Lisp
package that interfaces Emacs to third-party Java application
development tools, such as those provided by Oracle as part of its JDK.
The result is an integrated development environment (IDE) comparable in
power to many commercial Java IDEs.  Features include:

   • source code editing with syntax highlighting and auto indentation

   • automatic completion of class fields and methods

   • compilation with automatic jump from error messages to responsible
     line in the source code.

   • generates class and method skeletons automatically

   • run Java application in an interactive (comint) Emacs buffer

   • integrated debugging with interactive debug command buffer and
     automatic display of current source file/line when stepping through
     code

   • browse JDK doc, using the browser of your choice

   • browse your source code, using the Emacs etags facility or a
     tree-structured speedbar.

   • supports latest version of JDK

   • runs on any platform supported by Emacs and JDK (e.g., Linux,
     Windows and Solaris)

   • easily and infinitely customizable

   • works with FSF Emacs and XEmacs


File: jdee.info,  Node: JDEE Requirements,  Next: Latest Version,  Prev: About,  Up: Introduction

1.1.2 JDEE Requirements
-----------------------

The JDEE requires the following software:

   • FSF Emacs or XEmacs on Unix platforms; the 23.4 or later version of
     Emacs on Windows platforms, for general source file editing and
     tool integration functions

   • Java Development Kit (JDK) or compatible set of Java development
     tools (compiler, virtual machine, debugger, class libraries, etc.)

   • Web browser for viewing documentation

   • Bash or another Unix-style shell highly recommended for Windows
     environments.  The cygwin Unix emulation package for Windows from
     Red Hat includes Bash


File: jdee.info,  Node: Latest Version,  Next: Installing the JDEE,  Prev: JDEE Requirements,  Up: Introduction

1.1.3 Latest Version
--------------------

See <Downloading the JDEE> on the JDEE website for instructions on
downloading the most recent version of the JDEE.


File: jdee.info,  Node: Installing the JDEE,  Next: Reporting bugs,  Prev: Latest Version,  Up: Introduction

1.1.4 Installing the JDEE
-------------------------

See the JDEE Installation Guide on the JDEE website for information on
installing the JDEE on your system.


File: jdee.info,  Node: Reporting bugs,  Prev: Installing the JDEE,  Up: Introduction

1.1.5 Reporting bugs, enhancement suggestions
---------------------------------------------

Please send bug reports and enhancement suggestions to
<jdee-users@lists.sourceforge.net>.


File: jdee.info,  Node: Registering and Selecting a JDK,  Next: Editing Java Source Files,  Prev: Introduction,  Up: User's Guide

1.2 Registering and Selecting a JDK
===================================

The JDEE relies on command-line Java development tools, such as those
supplied by Oracle as part of its Java Development Kit (JDK). Before you
can use the JDEE to compile, debug, or run an application, you must tell
it where the Java compiler, debugger, and virtual machine are located on
your system.  The JDEE assumes that the compiler, debugger, and vm are
named javac, jdb, and java, respectively, and that they are located on
your system’s command path.  If these tools are not located on the
system command path or have different names, you must tell the JDEE
where they are located.  The JDEE provides customization variables for
specifying the locations of individual tools.

   However, if you are using one or more versions of Oracle’s JDK or a
clone of the JDK, the easiest way to specify the location of the
external development tools is to register the version of the JDK that
you intend to use.  It is especially advantageous to register a JDK, if
you intend to use multiple versions of the JDK. The reason?  Registering
each version of the JDK allows you to change JDKs by changing a single
customization variable.  The following sections explain how to register
and select JDKs.

* Menu:

* Registering a JDK::
* Selecting a JDK::


File: jdee.info,  Node: Registering a JDK,  Next: Selecting a JDK,  Prev: Registering and Selecting a JDK,  Up: Registering and Selecting a JDK

1.2.1 Registering a JDK
-----------------------

To register a version of the JDK with the JDEE:

  1. Type M-x customize-variable RET jdee-jdk-registry RET.

     The jdee-jdk-registry customization buffer appears.

  2. Click the INS button.

     Enter the version number of the JDK and the path of the directory
     in which the JDK is installed.

  3. Repeat the preceding steps until you have entered the versions and
     paths of all versions of the JDK that you wish to use with the
     JDEE.

  4. Click the ‘Save for Future Sessions’ from the State menu.  This
     saves the setting of jdee-jdk-registry in your init file.


File: jdee.info,  Node: Selecting a JDK,  Prev: Registering a JDK,  Up: Registering and Selecting a JDK

1.2.2 Selecting a JDK
---------------------

To select a JDK:

  1. Type M-x customize-variable RET jdee-jdk RET.

     The jdee-jdk customization buffer appears.

  2. The buffer lists the JDKs that you have previously registered
     (*note Registering a JDK::).

  3. Click the radio button next to the version of the JDK you want to
     use.

  4. Click the ‘Save for Future Sessions’ from the State menu.  This
     saves the setting of jdee-jdk-registry in your init file.

     Note: This procedure saves your JDK selection in your init file so
     that it applies to all projects.  You can configure the JDEE to use
     different JDKs for different projects by saving your customization
     in a project file.  (see Using Project Files) for more information.


File: jdee.info,  Node: Editing Java Source Files,  Next: Documenting Code,  Prev: Registering and Selecting a JDK,  Up: User's Guide

1.3 Editing Java Source Files
=============================

To edit an existing Java source file, load it into an Emacs buffer by
executing ‘C-x C-f’.  Loading a Java source file into a buffer causes
the buffer to enter into jdee-mode, a variant of java-mode, which is in
turn a variant of the standard Emacs cc-mode for editing source files
written in C and related languages.  jdee-mode offers all the
specialized source file editing commands of cc-mode plus functions for
creating, compiling, building, running, and debugging Java source files.
You can invoke the commands by selecting them from the JDEE menu that
jdee-mode displays on the Emacs menu bar or by typing the commands in
the Emacs minibuffer.


File: jdee.info,  Node: Documenting Code,  Next: Abbreviations,  Prev: Editing Java Source Files,  Up: User's Guide

1.4 Documenting Code
====================

The JDEE provides complete support for generating HTML documentation for
Java classes from comments inserted into the source code for those
classes.

   See also Displaying Java Documentation.

* Menu:

* Inserting Javadoc Comments::
* Generating the Documentation::


File: jdee.info,  Node: Inserting Javadoc Comments,  Next: Generating the Documentation,  Prev: Documenting Code,  Up: Documenting Code

1.4.1 Inserting Javadoc Comments
--------------------------------

To insert a skeleton javadoc comment for a class or method, position
point in the first line of the method or class and select JDEE->Document
from the Emacs menubar or type ‘C-c C-v j’.

   To customize the javadoc skeletons, select
JDEE->Options->Project->Javadoc from the Emacs menubar.

   Thanks to David Ponce for developing the JDEE’s javadoc comment
generation facility.


File: jdee.info,  Node: Generating the Documentation,  Prev: Inserting Javadoc Comments,  Up: Documenting Code

1.4.2 Generating the Documentation
----------------------------------

To generate documentation for the current project, open any source file
in the project and select Make Doc from the JDEE menu or enter M-x
jdee-javadoc-make.

   The jdee-javadoc-make command runs the JDK’s javadoc program to
generate the documentation.  The javadoc command must be on your
system’s command path.

   The jdee-javadoc-make command uses jdee-global-classpath as the
-classpath and jdee-sourcepath as the -sourcepath option for generating
the doc.  You can specify all other javadoc options via JDEE
customization variables.  To specify the options, select
Project->Options->Javadoc from the JDEE menu.  Use
jdee-javadoc-gen-packages to specify the packages, classes, or source
files for which you want to generate javadoc.  If this variable is nil,
the jdee-javadoc-make generates javadoc for the Java source file in the
current buffer.

   Thanks to Sergey A Klibanov for developing the JDEE’s javadoc
generation facility.


File: jdee.info,  Node: Abbreviations,  Next: Completing Expressions,  Prev: Documenting Code,  Up: User's Guide

1.5 Abbreviations
=================

The JDEE allows you to use abbreviations for Java keywords and control
flow constructs.  The following sections explain how to use these
abbreviations.

* Menu:

* Keyword Abbreviations::
* Control Flow Abbreviations::


File: jdee.info,  Node: Keyword Abbreviations,  Next: Control Flow Abbreviations,  Prev: Abbreviations,  Up: Abbreviations

1.5.1 Keyword Abbreviations
---------------------------

The JDEE defines a set of abbreviations for Java keywords.  When you
type one of these abbreviations followed by a space in a Java source
buffer, the JDEE optionally expands the abbreviation into the keyword.
For example, when the abbreviation mode is enabled, you need only type
fa followed by a space to enter the Java keyword false.

   To enable or disable abbreviation mode by default for a project,
select JDEE->Project->Options ->General and toggle the boolean variable
jdee-enable-abbrev-mode.

   To toggle abbreviation mode on or off during a session, select
JDEE->Code Generation->Modes->Abbrev.

   To change, remove, or add an abbreviation, edit the variable
jdee-mode-abbreviations in the project customization buffer.

     Note: The JDEE’s Java keyword expansion facility is based on the
     Emacs abbrev-mode facility.  For more information, see the Emacs
     user manual.


File: jdee.info,  Node: Control Flow Abbreviations,  Prev: Keyword Abbreviations,  Up: Abbreviations

1.5.2 Control Flow Abbreviations
--------------------------------

The JDEE defines abbreviations for Java control flow structures, such as
‘if-then-else’.  When you enter the abbreviation followed by a space,
the JDEE expands the abbreviation into a corresponding control structure
template.

   Example: expanding the ‘if-then-else’ abbreviation:

     ife

   expands to the control flow structure:

     if ( ) { } // end of if () else } // end of if () else

   The JDEE defines the following abbreviations for control structures:
     Statement                                          Abbreviation
     --------------------------------------------------------------
     if-then                                            if
     else                                               else
     if-then-else                                       ife
     else-if                                            eif
     while                                              while
     for                                                for
     for (int I=0;I<UL;I++)                             fori
     for (Iterator i = c.iterator(); i.hasNext();)      foriter
     main method                                        main
     switch                                             switch
     case                                               case
     try                                                try
     catch                                              catch
     try finally                                        tryf
     finally                                            finally

     Note: You must enable the JDEE’s Java keyword abbreviation mode to
     use the control flow abbreviations.  See Java Keyword Completion
     for more information.

   Thanks to Eric D. Friedman for contributing the control flow
templates.

* Menu:

* Left Brace Placement::
* Customizing the Control Flow Templates::
* Adding Your Own Control Flow Templates::
* Enabling Variable Content::
* Disabling the Control Flow Abbreviations::


File: jdee.info,  Node: Left Brace Placement,  Next: Customizing the Control Flow Templates,  Prev: Control Flow Abbreviations,  Up: Control Flow Abbreviations

1.5.2.1 Left Brace Placement
............................

The JDEE’s Java control flow templates support two options for opening
brace placement: placement on the first line of the template (Kerningham
& Ritchie Style, the default) and placement on a separate line.

   Type M-x customize-variable jdee-gen-k&r to specify the style you
prefer.


File: jdee.info,  Node: Customizing the Control Flow Templates,  Next: Adding Your Own Control Flow Templates,  Prev: Left Brace Placement,  Up: Control Flow Abbreviations

1.5.2.2 Customizing the Control Flow Templates
..............................................

You can customize the templates to suit any indentation style.  To
customize the templates, select Project->Options->Autocode from the JDEE
menu.


File: jdee.info,  Node: Adding Your Own Control Flow Templates,  Next: Enabling Variable Content,  Prev: Customizing the Control Flow Templates,  Up: Control Flow Abbreviations

1.5.2.3 Adding Your Own Control Flow Templates
..............................................

Use the jdee-gen-define-abbrev-template function to define your own
control flow abbreviation in your .emacs file.  For example, the
following code defines an abbreviation for an else clause.

     (jdee-gen-define-abbrev-template "melse" '('> "else {" '> 'n
     '> 'r 'n "}"))

   The jdee-gen-define-abbrev-template function takes two arguments.
The first argument is a string that specifies the abbreviation.  The
section argument is a list defining the text that replaces the
abbreviation.  The list can contain any of the following elements.

   Template Elements and their usage:

A string.
     The string is inserted into the buffer at point.

The symbol ’p.
     This position is saved in tempo-marks.

The symbol ’r.
     If tempo-insert is called with ON-REGION non-nil the current region
     is placed here.  Otherwise it works like ’p.

(p PROMPT <NAME> <NOINSERT>)
     If tempo-interactive is non-nil, the user is prompted in the
     minbuffer with PROMPT for a string to be inserted.  If the optional
     parameter NAME is non-nil, the text is saved for later insertion
     with the s tag.  If there already is something saved under NAME
     that value is used instead and no prompting is made.  If NOINSERT
     is provided and non-nil, nothing is inserted, but text is still
     saved when a NAME is provided.  For clarity, the symbol ’noinsert
     should be used as argument.

(P PROMPT <NAME> <NOINSERT>)
     Works just like the previous element, but forces tempo-interactive
     to be true.

(r PROMPT <NAME> <NOINSERT>)
     Like the previous, but if tempo-interactive is nil and tempo-insert
     is called with ON-REGION non-nil, the current region is placed
     here.  This usually happens when you call the template function
     with a prefix argument.

(s NAME)
     Inserts text previously read with the (p ..)  construct.  Finds the
     insertion saved under NAME and inserts it.  Acts like ’p if
     tempo-interactive is nil.

’&
     If there is only whitespace between the line start and point,
     nothing happens.  Otherwise a newline is inserted.

’%
     If there is only whitespace between point and end-of-line nothing
     happens.  Otherwise a newline is inserted.

’n
     Inserts a newline.

’>
     The line is indented using indent-according-to-mode.  Note that you
     often should place this item after the text you want on the line.

’n>
     Inserts a newline and indents line.

’r>
     Like r, but it also indents the region.

’o
     Like ’% but leaves the point before the new line.

Anything else.
     It is evaluated and the result is treated as an element to be
     inserted.  One additional tag is useful for these cases.  If an
     expression returns a list ’(l foo bar), the elements after ’l will
     be inserted according to the usual rules.  This makes it possible
     to return several elements from one expression.


File: jdee.info,  Node: Enabling Variable Content,  Next: Disabling the Control Flow Abbreviations,  Prev: Adding Your Own Control Flow Templates,  Up: Control Flow Abbreviations

1.5.2.4 Enabling Variable Content
.................................

Some templates optionally prompt you for items to insert into the
template.  To enable prompting, set the variable tempo-interactive to a
non-nil value in your .emacs file.


File: jdee.info,  Node: Disabling the Control Flow Abbreviations,  Prev: Enabling Variable Content,  Up: Control Flow Abbreviations

1.5.2.5 Disabling the Control Flow Abbreviations
................................................

To disable the control flow abbreviations, set the variable
jdee-gen-cflow-enable off.


File: jdee.info,  Node: Completing Expressions,  Next: Dynamic Keyword Completion,  Prev: Abbreviations,  Up: User's Guide

1.6 Completing Expressions
==========================

Both Emacs and the JDEE provide commands for completing incomplete
expressions.  Emacs provides commands that work for any expression but
only if the completions exist in an open buffer.  The JDEE provides
completion commands that work for any Java method or field name that
exists on jdee-global-classpath.  The following sections explain how to
use completion facilities supplied by the JDEE and by Emacs itself.

* Menu:

* Completing Method and Field Names::
* Selecting a Completion Method::
* Using Menu-Based Completion::
* Using In-Line Completion::
* Speeding Up Completion::


File: jdee.info,  Node: Completing Method and Field Names,  Next: Selecting a Completion Method,  Prev: Completing Expressions,  Up: Completing Expressions

1.6.1 Completing Method and Field Names
---------------------------------------

The JDEE provides comamnds that can complete an incomplete field or
method name.  All the methods determine the set of possible completions
for an incomplete field or method name at point.  They differ in how
they present the completions to you for selection.  The commands
include:

‘jdee-complete-in-line’
     This command uses the first completion that it finds to complete
     the method or field name at point.  If multiple completions exist,
     it allows you to cycle through the completions, each completion
     replacing the previous in the source buffer.  See Using In-Line
     Completion for more information.

‘jdee-complete-menu’
     This command displays a menu of possible completions for the
     incomplete method or field name at point.  It enters the completion
     that you select in the source buffer.  See Using Menu-Based
     Completion for more information.

‘jdee-complete-minibuf’
     This command uses the minibuffer to display possible completions
     for the incomplete method or field name at point.  The comamnd
     enters the completion that you select in the source buffer.  See
     Using Minibuffer-Based Completion for more information.

‘jdee-complete’
     This is the JDEE’s user-definable "standard" completion command.
     It delegates completion to one of the JDEE’s other completion
     commands (jdee-complete-menu by default) or to a custom completion
     function that you specify (*note Selecting a Completion Method::
     for more information.)  The ‘jdee-complete command’ is bound by
     default to the key combination ‘C-c C-v C-.’.  If you prefer
     another binding, use the customization variable ‘jdee-key-bindings’
     to change the binding.

   The JDEE’s field and method completion commands use the Beanshell to
run Java code that in turn uses Java’s reflection (class introspection)
capability to determine the fields and methods defined for the class of
object at point.  The commands start the Beanshell if it is not running.
This can cause a noticeable delay in completion the first time it is
used in a session.  The response can also be slow for classes containing
many methods and fields.

     Note: *note Speeding Up Completion:: for some tips on how you can
     dramatically speed up field and method completion.

   Completion works only for compiled classes that reside in the
classpath defined by ‘jdee-global-classpath’, if set, otherwise by the
‘CLASSPATH’ environment variable when the Beanshell starts.  Thus, if
the JDEE is unable to complete a method or field, make sure that the
class that defines the field or method is compiled and exists on the
classpath defined by ‘jdee-global-classpath’, if set, otherwise by the
‘CLASSPATH’ environment variable.

   The JDEE completion commands work for all of the following cases:
   • objects referenced by variables declared in the current buffer

   • static fields and methods

   • fields and methods of objects defined by the current class and its
     parent

     Names of fields and methods of the current class must start with
     this or .  (period).  Names of fields and methods declared by the
     parent of the current class must start with super.

     For example, this command completes:
          . ^ this. ^ super. ^

   • objects referenced by the fields of objects referenced by variables
     declared in the current class or its parent or by static fields

     For example, this command completes:
          System.out.prin ^

   • objects returned by methods of objects referenced by variables
     defined in the current

     For example, this command completes:
          Toolkit.getDefaultToolkit().get ^

   • objects referenced by method parameters

     For example, this command completes:
          void setColor(String color) { color.get ^ }


File: jdee.info,  Node: Selecting a Completion Method,  Next: Using Menu-Based Completion,  Prev: Completing Method and Field Names,  Up: Completing Expressions

1.6.2 Selecting a Completion Method
-----------------------------------

The JDEE’s generic completion command, ‘jdee-complete’ delegates
completion to one of several specific completion commands supplied by
the JDEE or to a custom completion method that you supply.  This allows
you to customize jdee-complete to use the completion method that you
prefer.

   To specify your preferred completion method:

  1. Type M-x jdee-complete-function RET

  2. Select the completion command that implements the completion method
     you prefer.

  3. If you selected Custom as your preferred completion function, enter
     the name of the custom completion function in the adjacent edit
     field, replacing the existing contents (ignore by default.).

  4. Save your selection in your .emacs or project file.


File: jdee.info,  Node: Using Menu-Based Completion,  Next: Using In-Line Completion,  Prev: Selecting a Completion Method,  Up: Completing Expressions

1.6.3 Using Menu-Based Completion
---------------------------------

The jdee-complete-menu displays a popup menu of completions for the
method or field name at point.  Selecting a completion from the menu
causes the command to use it to complete the method or field at point.
This section assumes that you have selected jdee-complete-menu as your
standard completion command.

   To select completions from a menu:

  1. Position point immediately following the partially complete field
     or method name.

  2. Type the ‘C-c C-v C-.’ key combination.

  3. Select the desired completion from the menu.

  4. The JDEE inserts the completion at point in the buffer.


File: jdee.info,  Node: Using In-Line Completion,  Next: Speeding Up Completion,  Prev: Using Menu-Based Completion,  Up: Completing Expressions

1.6.4 Using In-Line Completion
------------------------------

The jdee-complete-in-line command allows you to select completions at
the point of insertion in the source buffer.  The command finds all the
fields and methods that complete the name at point.  It then inserts the
first potential completion in the buffer at point.  Repeatedly executing
the command causes the JDEE to cycle through the other potential
completions.  If the completion is a method name, the command completes
the method name and displays the method signature in the minibuffer.

   The ‘jdee-complete-in-line’ command is bound to ‘C-c C-v .’.  You can
use this combination to invoke the command or ‘C-c C-v C-.’, if you have
selected this command as your preferred completion method.  The
following examples use the ‘C-c C-v .’ combination.

   Example: completing a String Method Name

   Typing ‘C-c-C-v-.’

     String s; s.get ^

   completes the method name at point as follows

     String s; s.getClass( ^

   and displays

     java.lang.Class getClass()

   in the minibuffer.  Repeatedly typing ‘C-c-C-v-.’ cycles through all
the other get methods for the Java String class.


File: jdee.info,  Node: Speeding Up Completion,  Prev: Using In-Line Completion,  Up: Completing Expressions

1.6.5 Speeding Up Completion
----------------------------

Here are two ways you can significantly speed up field and method
completion:

   • Byte-compile the EIEIO and JDEE packages.

   • The beanshell package, the Emacs interface to the BeanShell, is
     based on the EIEIO object-oriented Lisp package for Emacs.
     Completion uses the BeanShell heavily to determine the class of the
     field or method at point.  Thus compiling EIEIO and ‘beanshell.el’
     improves completion’s performance, dramatically in my tests.

   • Import by class, not by package, in your Java files.

     Every package import, e.g., ‘java.util.*’, requires invoking the
     BeanShell to determine the fully qualified name of the class at
     point (see jdee-parse-get-qualified-name).  A Beanshell invocation
     is by far the most time-consuming operation required for
     completion.  Thus eliminating the use of package-level imports can
     significantly speed up completion.


File: jdee.info,  Node: Dynamic Keyword Completion,  Next: Generating Code,  Prev: Completing Expressions,  Up: User's Guide

1.7 Dynamic Keyword Completion
==============================

Emacs provides dynamic completion commands that attempt to find
completions for the word at point in the current buffer or other
buffers.

   Example: Using Dynamic Completion

   Suppose that the current source buffer contains the class names
Component and Container.  Now suppose you enter Co somewhere in the
buffer and type ‘M-/’.  The text Component replaces Co in the buffer.

   Typing ‘M-/’ again changes Component to Container.  In this way, you
can cycle through all the possible completions for Co in the current
buffer.

* Menu:

* Dynamic Completion Commands::
* Electric Return::


File: jdee.info,  Node: Dynamic Completion Commands,  Next: Electric Return,  Prev: Dynamic Keyword Completion,  Up: Dynamic Keyword Completion

1.7.1 Dynamic Completion Commands
---------------------------------

Emacs provides two dynamic completion commands.

   The ‘dabbrev-expand’ command is bound to the key combination ‘M-/’ by
default.  It searches the current buffer for completions of the word at
point and, if none are found, other buffers of the same type.  For
example, if the current buffer is a Java source buffer, it searches
other Java source buffers for completions if none are found in the
active buffer.

   The ‘hippie-expand’ command provides more extensive search
capabilities.  See the docstrings for these functions for more
information.


File: jdee.info,  Node: Electric Return,  Prev: Dynamic Completion Commands,  Up: Dynamic Keyword Completion

1.7.2 Electric Return
---------------------

In electric return mode, pressing the ‘Enter’ key causes the JDEE to
close open braces at the end of a line.  To enable or disable this mode
by default, customize jdee-electric-return-p.

   To turn the mode on or off during a session, select JDEE->Code
Generation->Modes->Electric Return.


File: jdee.info,  Node: Generating Code,  Next: Checking Coding Style,  Prev: Dynamic Keyword Completion,  Up: User's Guide

1.8 Generating Code
===================

The JDEE provides the following code generation capabilities.  Code
wizards Code templates

* Menu:

* Generating Import Statements::
* Code Wizards::
* Code Templates::


File: jdee.info,  Node: Generating Import Statements,  Next: Code Wizards,  Prev: Generating Code,  Up: Generating Code

1.8.1 Generating Import Statements
----------------------------------

The JDEE provides a set of commands that generate and organize import
statements in the current buffer.  The commands automate the following
tasks:

* Menu:

* Importing Classes::           Generate an import statement for the class at point
* Importing All Classes::       Generate import statements for all classes in the current buffer that need import statements
* Expanding Package Imports::   Expand a package import statement into specific class imports
* Collapsing Class Imports::    Collapse class imports into a package import statement
* Grouping Imports::            Group import statements
* Deleting Unneeded Imports::   Delete superfluous import statements


File: jdee.info,  Node: Importing Classes,  Next: Importing All Classes,  Prev: Generating Import Statements,  Up: Generating Import Statements

1.8.1.1 Importing Classes
.........................

The JDEE->Import->Class (jdee-import-find-and-import, C-c C-v C-z)
command generates an import statement for the class at point in the
current buffer.  It inserts the import statement at the head of the
buffer.

   This command uses the BeanShell to search the classpath of the
current project for classes that match the name of the class at point.
The class name may be unqualified.

     Note: The classpath that the import wizard searches for import
     candidates is the classpath specified by the value of
     jdee-global-classpath for the current project.

   If the command finds more than one class of the same unqualified name
on the current classpath, it prompts you to select one of the classes to
import.

   The customization variable jdee-import-excluded-classes allows you to
specify rules for excluding classes from consideration for import into
the current source file.  If the import command finds any classes on the
classpath that belong to the list of prohibited classes, it removes them
from the list of classes considered for import into the current buffer.

   You can use either regular expressions or Lisp functions to specify
class exclusion rules.  For each rule, you can also specify that all
classes whose unqualified names match the rule be excluded from
consideration for import.  This is useful for preventing the JDEE from
importing alternate implementations of standard Java classes that do not
need to be imported.

   For example, the default setting for jdee-import-excluded-classes
includes a rule to exclude all classes belonging to the java.lang
package because every Java class implicitly imports this package.  The
default setting for jdee-import-excluded-classes also excludes all
unqualified synonyms of classes belonging to the java.lang package.
This prevents importation of alternate implementations of these classes,
e.g., alternate implementations of java.lang.String, included in some
commonly used class libraries and intended for internal use.  See the
docstring for jdee-import-excluded-classes for more information.

   Thanks to Len Trigg for contributing the initial implementation of
the import wizard and to Martin Schwarmberger for significantly
enhancing the import wizard.


File: jdee.info,  Node: Importing All Classes,  Next: Expanding Package Imports,  Prev: Importing Classes,  Up: Generating Import Statements

1.8.1.2 Importing All Classes
.............................

The JDEE->Code Generation->Import->All (jdee-import-all, C-c C-v z)
imports all the classes that need to be imported into the current
buffer.

   The command imports all classes that meet the following conditions:
   • The class’s base name begins with an uppercase letter.

   • The class’s base name contains at least one noninitial lowercase
     letter.

   • The class is not already imported into the buffer.

   • The class is not in jdee-import-excluded-classes.

   • The class exists on the current classpath.

   If more than one import candidate with the same base name exists on
the classpath, the JDEE displays a dialog that allows you to select one
of the candidates.

     Note: You can use the JDEE->Code Generation->Import->Import All
     Unique (jdee-import-all-unique ) command to avoid the dialog box.
     This command imports all classes whose unqualified names appear
     only once on the classpath.

   Thanks to Phillip Lord for contributing the initial implementation of
the Import All Wizard.


File: jdee.info,  Node: Expanding Package Imports,  Next: Collapsing Class Imports,  Prev: Importing All Classes,  Up: Generating Import Statements

1.8.1.3 Expanding Package Imports
.................................

To expand a package import statement, select JDEE->Code
Generation->Import->Expand Package Imports (jdee-import-expand-imports).
This command replaces a package import statement, e.g.:

     import java.io.*;

   with import statements for the members of that package referenced by
the current buffer, e.g.:

     import java.io.BufferedReader;
     import java.io.InputStreamReader;
     import java.io.IOException;


File: jdee.info,  Node: Collapsing Class Imports,  Next: Grouping Imports,  Prev: Expanding Package Imports,  Up: Generating Import Statements

1.8.1.4 Collapsing Class Imports
................................

To collapse class import statements in the current buffer into package
imports, select JDEE->Code Generation->Import->Collapse Class Imports
(jdee-import-collapse-imports).  This command collapses imports for any
package that contains as many as or more than the number of imports
specified by jdee-import-collapse-imports-threshhold.  The default value
of this variable is 2.  This causes this command to collapse imports for
any package from which the current buffer imports two or more classes.
For example, this command, by default, collapses:

     import java.io.BufferedReader;
     import java.io.InputStreamReader;
     import java.io.IOException;

   to

     import java.io.*;


File: jdee.info,  Node: Grouping Imports,  Next: Deleting Unneeded Imports,  Prev: Collapsing Class Imports,  Up: Generating Import Statements

1.8.1.5 Grouping Imports
........................

To organize import statements into groups of related imports, select
JDEE->Code Generation->Import->Organize Imports (jdee-import-organize).
By default this command groups import statements into two groups
separated by a blank line.  The first group contains all imports from
the java and javax packages.  The other group contains imports from all
other packages.  The imports are sorted alphabetically in ascending
order in each group, e.g.:

     import java.io.InputStreamReader;
     import java.util.Hashtable;
     import javax.swing.JFrame;
     import javax.swing.JPanel;

     import jmath.LinearSystem;
     import jmath.Test;

   The following variables allow you to customize the organization of
imports into groups:

‘jdee-import-group-function’
     This variable allows you to specify a function that assigns imports
     to groups.  The default group function is jdee-import-group-of,
     which uses rules specified by the following variable to assign
     imports to groups.

‘jdee-import-group-rules’
     This variable specifies a list of rules for assigning import
     statements to group, e.g., ’(("^javax\\."  .  "Swing")), Each rule
     consists of two parts: a regular expression and an optional group
     name specifier.  The jdee-import-group-of function assigns an
     import statement to the group if it matches the regular expression.
     The group name specifier is either a string that specifies the name
     or an index to a component of the regular expression to be used as
     the group name.

‘jdee-import-insert-group-names’
     Specifies whether to insert an import group’s name in the buffer.

‘jdee-import-default-group-name’
     Specifies the default name for an import group.

‘jdee-import-blank-line-between-groups’
     Specifies whether to insert a blank line between import groups.

‘jdee-import-sorted-groups’
     Specifies whether and how to sort groups of packages.  Options
     include no sorting, in the order specified by grouping rules, or in
     ascending or descending alphabetical order.


File: jdee.info,  Node: Deleting Unneeded Imports,  Prev: Grouping Imports,  Up: Generating Import Statements

1.8.1.6 Deleting Unneeded Imports
.................................

To delete superfluous import statements from the current buffer, select
JDEE->Code Generation->Import->Delete Unneeded
(jdee-import-kill-extra-imports).  This command deletes all import
statements for classes that are not actually referenced by the class in
the current buffer.


File: jdee.info,  Node: Code Wizards,  Next: Code Templates,  Prev: Generating Import Statements,  Up: Generating Code

1.8.2 Code Wizards
------------------

The JDEE provides a set of procedural code generators called code
wizards.  They include:

   Method Override Wizard A method that overrides a method inherited by
the class containing point.

   Interface Wizard Implementation of an interface in the class
containing point.

   Delegate Wizard Methods that delegate tasks to a specified class.

   Abstract Class Wizard Implementations of the abstract methods
inherited by the class containing point.

   Get/Set Wizard Get and set methods for the private fields of the
class containing point.

     Note: Some of the wizards use the BeanShell to run Java code.  A
     wizard starts the Beanshell interpreter if it is not already
     running.  Thus, you may experience a slight delay when invoking a
     wizard for the first time in a session.

* Menu:

* Method Override Wizard::
* Interface Wizard::
* Delegate Wizard::
* Get/Set Wizard::


File: jdee.info,  Node: Method Override Wizard,  Next: Interface Wizard,  Prev: Code Wizards,  Up: Code Wizards

1.8.2.1 Method Override Wizard
..............................

The method override wizard generates a skeleton method that overrides a
similarly named method defined by a superclass.

   To override a method of a superclass:
  1. Position the Emacs point at the location in the buffer where you
     want the generated method to appear.

     The point must be within the class that is overriding the method.

  2. Select Wizards->Override Method from the JDEE menu or enter M-x
     jdee-wiz-overrided-method.

     The JDEE prompts you to enter the name of the method to be
     overridden in the minibuffer.

     The name must be the name of a method defined by an ancestor of the
     class in which the Emacs point is located.  The compiled class of
     the ancestor must be on the classpath specified by
     jdee-global-classpath.

  3. Enter the name of the method to be overridden.

     If the ancestors of the class in which you are overriding the
     method define more than one method of the same name, the wizard
     displays a dialog buffer that lists the methods.  For example,
     Java’s awt class hierarchy defines several variants of the method
     repaint.  If you specify repaint as the method to override, the
     JDEE displays a dialog buffer.

     The dialog buffer lists the signature of each variant of the method
     you specified.  Next to each signature is a radio button.  The
     radio button of the currently selected signature contains an
     asterisk.  To select another signature, right-click the radio
     button next to the variant.  To confirm your selection and dismiss
     the dialog, right-click the [Ok] button.

  4. Select the method variant you want to override and click the [Ok]
     button.

     The wizard inserts a skeleton implementation of the selected method
     at the current point in the Java source buffer.

     The wizard also inserts import statements for any classes
     referenced by the method that are not already imported by the
     containing class either explicitly or implicitly.  The wizard
     inserts the import statements at the head of the source buffer
     after any existing import statements, or any package statement, or
     the first blank line in the buffer.

     Note: The method override wizard uses the BeanShell to create the
     interface implementation.  If the BeanShell is not currently
     running, the wizard starts the BeanShell.  Thus, if the BeanShell
     is not already running, you may experience a short pause the first
     time you override a method.


File: jdee.info,  Node: Interface Wizard,  Next: Delegate Wizard,  Prev: Method Override Wizard,  Up: Code Wizards

1.8.2.2 Interface Wizard
........................

This wizard creates a skeleton implementation of any interface defined
on the classpath specified by jdee-global-classpath.

   To create an implementation of an interface:
  1. If the interface is to be implemented by a new class, create the
     class in a buffer.

  2. Position the Emacs point at the point in the class where you want
     the implementation of the interface’s methods to appear.

  3. Select JDEE->Wizards->Implement Interface or enter M-x
     jdee-wiz-implement-interface.

     The JDEE prompts you to enter the name of the interface to be
     implemented.

  4. Enter the fully qualified name of the interface, for example,
     java.awt.Event.MouseListener.

     The wizard inserts skeleton implementations of the methods declared
     by the interface at the current point in the current buffer.  It
     inserts import statements for any classes required by the interface
     at the head of the current buffer (only if import statements do not
     already exist for the required classes).  It also updates or
     creates an implements clause for the class.

     Note: The interface wizard uses the BeanShell to create the
     interface implementation.  If the BeanShell is not currently
     running, it starts the BeanShell.  Thus, if the BeanShell is not
     already running, you may experience a short pause the first time
     you use the wizard.

   Thanks to Eric Friedman for creating the framework for the interface,
method override, and abstract class wizards and for contributing the
initial implementation of the interface wizard.


File: jdee.info,  Node: Delegate Wizard,  Next: Get/Set Wizard,  Prev: Interface Wizard,  Up: Code Wizards

1.8.2.3 Delegate Wizard
.......................

This wizard generates methods that delegate calls to a class in the
current buffer to an attribute of the class, i.e., to an object that is
a field of the current class.  For example, if the current buffer
contains class A and A has an attribute, A.b, that is an instance of
class B, this wizard generates all the public methods of class B in A
and delegates handling of those methods to b.

   Thanks to Charles Hart for contributing this wizard.


File: jdee.info,  Node: Get/Set Wizard,  Prev: Delegate Wizard,  Up: Code Wizards

1.8.2.4 Get/Set Wizard
......................

This wizard generates get and set methods for the private fields of the
class at point, but only if the fields do not already have get or set
methods.  To generate the methods, move point to the point in the class
where you want the get and set methods to appear.  Then select
JDEE->Code Generation->Wizards->Generate Get/Set Methods...  or enter
M-x jdee-wiz-get-set-methods

   Thanks to Javier Lopez and Sandip Chitale for contributing this
wizard.


File: jdee.info,  Node: Code Templates,  Prev: Code Wizards,  Up: Generating Code

1.8.3 Code Templates
--------------------

* Menu:

* Buffer Templates::
* Specifying Boilerplate Text::
* Code Templates Customization Variables::
* Point Templates::
* Customizing Templates::
* Creating Templates::
* Defining a Template and Template Insertion Function::
* Registering Custom Templates::
* Assigning Keys to Templates::


File: jdee.info,  Node: Buffer Templates,  Next: Specifying Boilerplate Text,  Prev: Code Templates,  Up: Code Templates

1.8.3.1 Buffer Templates
........................

These commands create buffers containing a skeleton Java class.  Each
command prompts you to enter the path to a new Java source file.  They
then create a buffer for the new file and insert a template for a class
of the same name as the newly created file.  In particular, the command:

‘Files->JDE New->Class’
     creates a buffer containing a generic Java public class

‘Files->JDE New->Console’
     creates a buffer containing the main class of a Java console
     application

‘Files->JDE New->Other’
     prompts you to create any of the above buffers or a custom
     (user-defined) buffer.

   You can create an empty Java class buffer by selecting Files->Open
(C-x f) and entering the path for a new file whose root name is the same
as the class you want to create and whose extension is .java.


File: jdee.info,  Node: Specifying Boilerplate Text,  Next: Code Templates Customization Variables,  Prev: Buffer Templates,  Up: Code Templates

Specifying Boilerplate Text
...........................

You can specify boilerplate text (for example, a copyright notice) to be
inserted at the head of class source files created by the JDE. The JDEE
provides two ways to specify the boilerplate text.  The simplest way is
to enter the lines of boilerplate text as the value of the customization
variable jdee-gen-buffer-boilerplate.  Another way to specify the text
is to set the value of the customization variable
jdee-gen-boilerplate-functionto a function that generates the
boilerplate text.  (The default value of this variable is
jdee-gen-create-buffer-boilerplate, which returns the value of the
boilerplate variable, jdee-gen-buffer-boilerplate).  The functional
approach allows you to generate boilerplate text dynamically by
evaluating the appropriate Lisp code.  By saving the values of
boilerplate variables in project files, you can specify different
boilerplate text for each project.


File: jdee.info,  Node: Code Templates Customization Variables,  Next: Point Templates,  Prev: Specifying Boilerplate Text,  Up: Code Templates

Customization Variables Code Templates
......................................

The following JDEE customization variables control creation of autocoded
Java source buffers:

Variable                         Group       Usage
---------------------------------------------------------------------------
jdee-gen-class-buffer-template   Autocode    Template for a generic
                                             public class buffer.
jdee-gen-console-buffer-template Autocode    Template for a console
                                             application buffer.
jdee-gen-jfc-app-buffer-template Autocode    Template for a JFC (Swing)
                                             application.
jdee-gen-junit-test-class-buffer-templateAutocodeTemplate for a JUnit test
                                             case class.  This template
                                             requires the JUnit test
                                             framework.
jdee-gen-buffer-templates        Autocode    Specifies templates
                                             available to create Java
                                             buffers.
jdee-gen-buffer-boilerplate      Autocode    Specifies lines of text to
                                             be inserted at the head of
                                             class files.
jdee-gen-boilerplate-function    Autocode    Specifies a function that
                                             returns a string of
                                             boilerplate text.  The
                                             default value is
                                             jdee-gen-create-buffer-boilerplate,
                                             which returns the value of
                                             jdee-gen-buffer-boilerplate.

   See Customizing Templates for information on how to customize the
class creation templates.


File: jdee.info,  Node: Point Templates,  Next: Customizing Templates,  Prev: Code Templates Customization Variables,  Up: Code Templates

1.8.3.2 Point Templates
.......................

The following commands insert templates at the current point in the
buffer:

JDEE->Generate->Get/Set Pair
     generates an instance variable and a get and set method for that
     variable

JDEE->Generate->Println
     generates a ‘System.out.println(...);’ statement.

JDEE->Generate->Action
     generates and registers an action listener for a specified
     component.

JDEE->Generate->Listener->Window
     generates and registers a window listener for a specified window.

JDEE->Generate->Listener->Mouse
     generates and registers a mouse listener for a specified component.

JDEE->Generate->Other
     allows you to select any of the above templates or a custom
     (user-defined) template.

   The following variables control generation of code at point:

Variable                         Group       Usage
---------------------------------------------------------------------------
jdee-gen-get-set-var-template    Autocode    Defines a get/set method
                                             pair template.
jdee-gen-listener-action-templateAutocode    Defines an action listener
                                             template.
jdee-gen-listener-window-templateAutocode    Defines a window listener
                                             template.
jdee-gen-listener-mouse-template Autocode    Defines a mouse listener
                                             template.
jdee-gen-inner-class-template    Autocode    Defines a template for
                                             creating a class inside
                                             another class or inside an
                                             existing source buffer.
jdee-gen-code-templates          Autocode    Specifies available code
                                             templates.

   See *note Customizing Templates:: for information on how to customize
templates provided by the JDEE.

   *note Creating Templates:: for information on how to create templates
from scratch.


File: jdee.info,  Node: Customizing Templates,  Next: Creating Templates,  Prev: Point Templates,  Up: Code Templates

1.8.3.3 Customizing Templates
.............................

You can customize the JDEE’s standard code templates, using the Emacs
customization feature.

   To customize an autocode template:
  1. Select JDEE->Options->Autocode

     The JDEE displays a customization buffer containing the autocode
     templates.

  2. Edit the template to suit your needs.

     The JDEE uses the template format defined by tempo.el to represent
     class templates.  Each template consists of a list of strings,
     symbols, and functions, each of which represents content to be
     inserted successively into the buffer at the current point.  The
     strings represent fixed content.  The symbols and functions
     represent variable content.  See the docstring for the function
     tempo-define-template for more information, including the meaning
     of special symbols such as ‘'n’.

  3. Select the state button associated with the template.

     A menu pops up with a list of options for saving your changes.

  4. Save your changes.

   Select Save for Future Sessions if you want your changes to apply to
all projects.  If you want your changes to apply only to the current
projects, select Set for Current Session.  Then select
JDEE->Options->Save Project to save your changes in the current
project’s project file.


File: jdee.info,  Node: Creating Templates,  Next: Defining a Template and Template Insertion Function,  Prev: Customizing Templates,  Up: Code Templates

1.8.3.4 Creating Templates
..........................

The JDEE considers any command (interactive function) that inserts code
into a buffer at point to be a template.  The JDEE uses the Emacs tempo
library to create built-in templates.  You can use tempo to create your
own, add-on templates (see below and the doc for the
tempo-define-template for more information) or create templates from
scratch.  In either case, once you have created a template, you can add
it to the JDE’s lists of available code and/or buffer templates, using
the JDEE’s jdee-gen-code-templates and/or jdee-gen-buffer-templates
variables, respectively.  Adding a template to these lists enables you
to invoke the templates from the JDEE menus.  When adding a template,
you need to specify a unique title for the template.  These titles
enable you to specify the templates when invoking them, using the JDE’s
custom code template commands (Files->JDE New->Custom and
JDEE->Generate->Custom).  You can use auto completion to enter a
template title when invoking a custom code generation command.  Note
that you can specify different sets of templates for different projects,
by setting and saving the template list variables in project files.  See
the following sections for more information:


File: jdee.info,  Node: Defining a Template and Template Insertion Function,  Next: Registering Custom Templates,  Prev: Creating Templates,  Up: Code Templates

Defining a Template and Template Insertion Function
...................................................

The tempo-define-template macro enables you to define a template and a
function that inserts that template at the current point in the current
buffer.  You specify the template as a list oftemplate elements where
each element is text, a special symbol, or a Lisp expression.  The
function inserts each text element exactly as specified in the buffer;
it replaces special symbols with some text (e.g., user input), and it
replaces Lisp expressions with the text that results from evaluating
them.

   For example, the following Lisp code:

     (tempo-define-template "foo"
     ;; template name
     '("System.out.println(\"foo\");")
     ;;template definition "f"
     ;; abbreviation "Inserts a print foo message")
     ;; template documentation

   defines a template for Java code that always prints "foo" to standard
out:

     System.out.println("foo");

   Notice that the template definition uses the Lisp string escape
character to specify the string "foo".  This is necessary when you want
to include quoted strings in a template definition.

   The sample Lisp form also defines an interactive template function
tempo-template-foo.  Now suppose you insert the sample code in your
.emacs file.  After Emacs starts up, whenever you enter the command M-x
tempo-template-foo, Emacs inserts:

     System.out.println("foo");

   at the current point in your Java source buffer (or any buffer, tempo
doesn’t care).

   The preceding example is admittedly not vary useful because it always
prints the same text.  You can create more useful templates, using
special tempo template symbols and lisp forms.  This approach, for
example, allows you to create a template that can print any user-defined
text to standard out:

     (tempo-define-template "debug"
     ;; template name '("if (debug)" n>
     ;; insert new line plus indent
     "System.out.println(" (p "Enter debug message:")       ;; Prompts for debug message
     ");") "d"
     ;; abbreviation "Inserts a print debug message")
     ;; template documentation

   The template function produced by this example prompts you to enter
the text to be printed when inserting the function into a buffer.  In
particular, it inserts:

     if (debug) System.out.println(DEBUG-MESSAGE);

   where DEBUG-MESSAGE is any text that you enter.  For example, suppose
you enter:

     "Selected color = " + color

   at the prompt.  The template function inserts:

     if (debug) System.out.println("Selected color = " + color);

   at the current point in the buffer.

   See the documentation for tempo-define-template (type c-h f
tempo-define-template) for more information on creating templates.


File: jdee.info,  Node: Registering Custom Templates,  Next: Assigning Keys to Templates,  Prev: Defining a Template and Template Insertion Function,  Up: Code Templates

Registering Custom Templates
............................

You can register templates that you create with the JDEE. When you
register a template with the JDEE, it appears among the list of
templates that you can select when you select JDEE->Generate->Other.....

   You register a template by customizing the JDEE variable
jdee-gen-code-templates.  The value of this variable is a list of the
template functions that the JDEE command JDEE->Generate->Other....  can
invoke.

   To register a custom template, add its name to the list.

   To insert a template that you have registered:

  1. Select JDEE->Generate->Other....

     The JDEE displays the prompt ‘Enter template:’ in the minibuffer.

  2. Enter the template’s name and press Enter or press the Tab key to
     display a list of templates in a completion buffer:

  3. Select the template you want by double-clicking its name.


File: jdee.info,  Node: Assigning Keys to Templates,  Prev: Registering Custom Templates,  Up: Code Templates

Assigning Keys to Templates
...........................

You can assign templates to keyboard keys to speed use of frequently
used templates.  For example, insert this form:

     (global-set-key [f9] 'jdee-gen-to-string-method)

   in your .emacs file to assign the ‘F9’ function key to the JDEE
template that generates a skeleton toString method.


File: jdee.info,  Node: Checking Coding Style,  Next: Compiling Java Programs,  Prev: Generating Code,  Up: User's Guide

1.9 Checking Coding Style
=========================

The JDEE->Check Style command (M-x jdee-checkstyle) command checks the
current buffer for conformity to a Java coding standard.  The default
standard is that specified by Oracle.  Execute jdee-checkstyle-customize
to customize the command to support your own coding standard.

   The command displays a list of stylistic faults in a popup buffer.
Click the error message to display the line that violates the standard.


File: jdee.info,  Node: Compiling Java Programs,  Next: Building Java Applications,  Prev: Checking Coding Style,  Up: User's Guide

1.10 Compiling Java Programs
============================

To compile the source file in the current buffer, select JDEE->Compile,
type ‘C-c-C-v-C-c’, or execute ‘M-x jdee-compile’.  The compiler uses
the version of javac included in the currently selected JDK or on your
system command path by default.  However, you can configure the JDEE to
use another compiler for the current project or all projects (see
Specifying a Compiler).  The JDEE also allows you to configure the JDEE
to invoke the compiler with various compilation options.

* Menu:

* Compilation Buffer::
* Specifying a Compiler::
* Compilation Options::


File: jdee.info,  Node: Compilation Buffer,  Next: Specifying a Compiler,  Prev: Compiling Java Programs,  Up: Compiling Java Programs

1.10.1 Compilation Buffer
-------------------------

The compile command displays the output of the compiler in a separate
compilation buffer.

   If a compilation buffer does not exist, the compile command creates
the buffer; otherwise, it reuses the existing compile output buffer.
The compilation buffer operates in compilation-mode, a standard Emacs
buffer mode.  This mode greatly simplify locating compilation errors in
the Java source code.  For example, to find the line that cause a
compilation error, simply click the error message in the compilation
buffer.


File: jdee.info,  Node: Specifying a Compiler,  Next: Compilation Options,  Prev: Compilation Buffer,  Up: Compiling Java Programs

1.10.2 Specifying a Compiler
----------------------------

The JDEE supports the following Java compilers:

javac
     This is the compiler that comes with Oracle’s JDK and the JDK’s
     clones.  Note that javac compiler is itself implemented in Java.
     The javac executable that comes with the JDK simply starts a VM to
     run javac.  The executable passes its command-line arguments to
     javac’s main method.

javac compile server
     This is a JDEE feature that uses the BeanShell to invoke the javac
     compiler on a source file, thus avoiding the need to start a VM
     everytime you want to compile a file.  This option greatly reduces
     the time required to compile individual files by eliminating the VM
     startup time, which is usually much longer than the time required
     to compile a file.

jikes
     Developed by IBM, this compiler is implemented in C++ and hence
     avoids the vm startup time that slows down javac.

   To specify one of these compilers for the current project or all
projects:
  1. Type M-x customize-variable RET

     Emacs prompts you to enter the name of a variable to customize.

  2. Enter jdee-compiler and press Enter.

     The jdee-compiler customization buffer appears.

  3. Select the compiler that you want to use for the current project or
     all projects.

     You can skip the next step if you selected the compile server or if
     you selected javac and you want to use the version of javac that
     comes with the currently selected JDK, or you have selected the
     javac executable or jikes and the executable for the selected
     compiler is in your system’s command path.

  4. Enter the path to the executable for the selected compiler.

  5. If you want your selection to apply only to the current project,
     select Save for Current Session from the State menu.  Otherwise
     select Save for Future Sessions.

  6. Select Finish to dismiss the customization buffer.

  7. If you want the selection to apply to the current project, select
     Project->Project File->Save from the JDEE menu.


File: jdee.info,  Node: Compilation Options,  Prev: Specifying a Compiler,  Up: Compiling Java Programs

1.10.3 Compilation Options
--------------------------

The JDEE allows you to specify compilation options by setting
compilation variables.  You must use the Emacs customization feature.
To use the customization feature, select JDEE->Options->Compile.  (See
Configuring the JDEE for more information on using the customization
feature).  To save the compilation settings in the project file (see
Using Project Files) for the current source buffer, select
JDEE->Options->Update Project.

* Menu:

* Setting Compile Options Interactively::
* Compiler Customization Variables::


File: jdee.info,  Node: Setting Compile Options Interactively,  Next: Compiler Customization Variables,  Prev: Compilation Options,  Up: Compilation Options

1.10.3.1 Setting Compile Options Interactively
..............................................

If you set the customization variable jdee-read-compile-args to a
non-nil value, the JDEE compile command prompts you to enter compilation
options in the minibuffer.  It appends the options that you enter to the
options specified via customization variables.  The JDEE saves the
arguments that you enter in a minibuffer history list.  You can recall
previously entered options by pressing the up or down arrows on your
keyboard.

     Note: The JDEE uses the values of the JDEE customization variables
     to set the compiler’s command-line option switches.  The JDEE
     assumes that the compiler you are using (specified by the
     customization variable jdee-compiler) has the same set of
     command-line switches as the version of javac or jikes that you
     have selected.  If the command-line switch for a particular option
     supported by the compiler your are using is not the same as that
     specified by javac or jikes, you must use the variable
     jdee-compile-option-command-line-args to select the option.


File: jdee.info,  Node: Compiler Customization Variables,  Prev: Setting Compile Options Interactively,  Up: Compilation Options

1.10.3.2 Compiler Customization Variables
.........................................

The following table lists the JDEE compilation variables and the
functions used to set them.

Name                                 Group   Usage
---------------------------------------------------------------------------
jdee-compiler                        Project Specifies the compiler
                                             (javac server, by default)
                                             to use to compile the code
                                             in the current source
                                             buffer.
jdee-compile-option-command-line-argsCompile Specifies a string of
                                             command-line arguments to
                                             be passed to the compiler.
jdee-global-classpath                Project Specify class paths for
                                             compile, run, and debug
                                             commands.
jdee-read-compile-args               Project Specify whether to read
                                             compile options from the
                                             minibuffer.
jdee-compile-option-classpath        Compile Specifies the classpath for
                                             compile command.  If set,
                                             this variable overrides
                                             jdee-global-classpath.
jdee-compile-option-sourcepath       Compile Specifies the path of
                                             source files for classes
                                             required to compile the
                                             current class.
jdee-quote-classpath                 Project Quote the classpath
                                             argument.
jdee-compile-option-directory        Compile Specifies the directory
                                             into which to place the
                                             compiled class.
jdee-compile-option-deprecation      Compile Warn of use or override of
                                             a deprecated member or
                                             class
jdee-compile-option-debug            Compile Generate information about
                                             local variables for debug
                                             tools.
jdee-compile-option-optimize         Compile Directs the compiler to try
                                             to generate faster varname.
jdee-compile-option-depend           Compile Analyze dependencies.
jdee-compile-option-depend-switch    Compile Command line switch that
                                             causes the compiler to
                                             analyze dependencies.
jdee-compile-option-vm-args          Compile Specify command-line
                                             arguments for Java
                                             interpreter used to run the
                                             compiler.
jdee-compile-option-verbose-path     Compile Print verbose messages.
jdee-compile-option-verbose          Compile List directories searched
                                             to compile current class.
jdee-compile-option-nowarn           Compile Turn off warnings.
jdee-compile-option-encoding         Compile Specify the source file
                                             encoding name, such as
                                             EUCJIS\SJIS.
jdee-compile-option-target           Compile Generate code compatible
                                             with a specified vm
                                             version.
jdee-compile-option-bootclasspath    Compile Specify classpath of
                                             standard libraries for
                                             target vm.
jdee-compile-option-bootclasspath    Compile Specify path of directories
                                             containing extensions for
                                             target vm.


File: jdee.info,  Node: Building Java Applications,  Next: Running Java Applications,  Prev: Compiling Java Programs,  Up: User's Guide

1.11 Building Java Applications
===============================

The JDEE->Build command builds an application.  By default this command
invokes the Unix-style make utility to build the application.  You can
configure the build command to invoke the Ant build system or a custom
build function.

* Menu:

* Selecting a Build Method::
* Building with Make::
* Building with Ant::


File: jdee.info,  Node: Selecting a Build Method,  Next: Building with Make,  Prev: Building Java Applications,  Up: Building Java Applications

1.11.1 Selecting a Build Method
-------------------------------

To select a build method:
  1. Type M-x customize-variable RET jdee-build-function RET

     The jdee-build-function customization buffer appears.

  2. Select the build function that you want to use.

  3. If you want your selection to apply only to the current project,
     select Save for Current Session from the State menu.  Otherwise
     select Save for Future Sessions.

  4. Select Finish to dismiss the customization buffer.

  5. If you want the selection to apply to the current project, select
     Project->Project File->Save from the JDEE menu.


File: jdee.info,  Node: Building with Make,  Next: Building with Ant,  Prev: Selecting a Build Method,  Up: Building Java Applications

1.11.2 Building with Make
-------------------------

The jdee-make command uses a make utility, such as GNU make, to rebuild
a project.  You must supply the makefiles used to build your projects.
See Sample Makefile for an example of a makefile for building a Java
project.  David Ponce’s JMaker package generates makefiles automatically
for JDEE projects.  It uses JDEE variables to determine classpaths,
compiler options, and other information needed to create projects.
JMaker recursively creates makefiles for all the Java packages in a
project plus a toplevel makefile that invokes the other makefiles to
build the entire project.

* Menu:

* Make Options::
* Sample Makefile::


File: jdee.info,  Node: Make Options,  Next: Sample Makefile,  Prev: Building with Make,  Up: Building with Make

1.11.2.1 Make Options
.....................

The following customization variables allow you to specify various
jdee-make options in Project group:

Name                                 Default Usage
---------------------------------------------------------------------------
jdee-make-program                    make    Specifies the pathname on
                                             your system of the make
                                             utility that the jdee-make
                                             uses to build your project.
jdee-make-args                               Specifies a string of
                                             command-line arguments (for
                                             example, "-f mymakefile
                                             all") to be passed to the
                                             make utility.
jdee-read-make-args                  nil     If non-nil, this variable
                                             causes the jdee-make
                                             command to prompt you to
                                             enter command-line
                                             arguments in the
                                             minibuffer.  jdee-make
                                             passes these arguments
                                             along with the arguments
                                             specified by jdee-make-args
                                             to the make utility.
jdee-make-working-directory                  Specifies the directory
                                             from which jdee-make runs
                                             the make utility.


File: jdee.info,  Node: Sample Makefile,  Prev: Make Options,  Up: Building with Make

1.11.2.2 Sample Makefile
........................

The following is a sample Makefile that you can use as a model for
creating makefiles to build Java projects.

     JDK = d:/jdk1.2/lib/classes.zip
     JMATH = d:/jmath/src
     CLASSPATH = $(JMATH);$(JDK)
     COMPILER = javac VM = java
     COPTIONS = -g -deprecation
     ROPTIONS =
     CLASSES = Test.class \
               JMathError.class \
               JMathException.class \
               LinearSystem.class

     .SUFFIXES: .java .class
     all : $(CLASSES)
       # Rebuild (if necessary) and run the JMath test suite. run: $(CLASSES)
       $(VM) -classpath "$(CLASSPATH)" jmath.Test

     # Remove all class files from the project directory.
     clean: rm *.class

     # Implicit rule for making Java class files from Java
     # source files.
     .java.class: $(COMPILER) $(COPTIONS) -classpath "$(CLASSPATH)" $?


File: jdee.info,  Node: Building with Ant,  Prev: Building with Make,  Up: Building Java Applications

1.11.3 Building with Ant
------------------------

The jdee-ant-build command uses the Apache Ant build tool to build a
Java project.

   The following variables allow you to control the build process.

Name                          Default        Usage
---------------------------------------------------------------------------
jdee-ant-invocation-method    script         Specifies how to invoke
                                             ant.  Ant can be invoked in
                                             one of three ways.  The
                                             first is via the ant
                                             script/program that comes
                                             with ant.  The second is
                                             via java and the third is
                                             via the Ant Server.
jdee-ant-home                                Directory where ant is
                                             installed.
jdee-ant-user-jar-files       nil            Specifies jar files that
                                             hold user-defined tasks.
jdee-ant-program              ant            Specifies name of ant
                                             program/script.
jdee-ant-args                 -emacs         Specifies arguments to be
                                             passed to the Ant program.
jdee-ant-buildfile            build.xml      Specifies the default
                                             buildfile to use.
jdee-ant-read-buildfile       off            Specify whether to prompt
                                             for a buildfile.  If
                                             non-nil, the jdee-ant-build
                                             command prompts you for an
                                             ant buildfile.  Note that
                                             jdee-ant-read-buildfile and
                                             jdee-ant-enable-find are
                                             incompatible and that
                                             jdee-ant-read-buildfile
                                             will override the former.
jdee-ant-read-target          off            Specify whether to prompt
                                             for a build target.  If
                                             non-nil, the jdee-ant-build
                                             command prompts you for an
                                             ant target.
jdee-ant-interactive-buildfileoff            Default buildfile to use
                                             when prompting
                                             interactively.
jdee-ant-read-args            off            Specify whether to prompt
                                             for additional arguments to
                                             pass to Ant.  If non-nil,
                                             the jdee-ant-build command
                                             prompts you for the
                                             additional arguments.
jdee-ant-enable-find          off            Specify whether jdee-ant
                                             find the build.xml file
                                             based on your current
                                             directory.  If non-nil, we
                                             will search up the
                                             directory hierarchy from
                                             the current directory for
                                             the build definition file.
                                             Also note that, if non-nil,
                                             this will relax the
                                             requirement for an explicit
                                             jde project file.  In order
                                             for this to work
                                             jdee-ant-read-buildfile
                                             must be nil.
jdee-ant-complete-target      off            Specify whether to enable
                                             completion of build target
                                             names in the minibuffer.
                                             If non-nil, the
                                             jdee-ant-build command
                                             allows you to use tab
                                             completion in the
                                             minibuffer to specify the
                                             build target name.  This
                                             list of valid build targets
                                             is determined by parsing
                                             the Ant build file.  This
                                             option has no effect if
                                             jdee-ant-read-target is
                                             nil.
jdee-ant-use-global-classpath off            Specify whether to enable
                                             use of
                                             jdee-global-classpath when
                                             running jdee-ant.
jdee-ant-target-regexp        <\s-*target\s-[^...]*?name\s-*=\s-*\"\s-*\([^\"]+\)Regular expression used to
                                             match target names in Ant
                                             build files.
jdee-ant-build-hook           nil            List of hook functions run
                                             by jdee-ant-build (see
                                             run-hooks in the Emacs
                                             documentation for more
                                             information).


File: jdee.info,  Node: Running Java Applications,  Next: Working with Applets,  Prev: Building Java Applications,  Up: User's Guide

1.12 Running Java Applications
==============================

The JDEE allows you to run a Java application as an Emacs subprocess.
You can run multiple applications concurrently, but only one instance of
each application at a time.  The JDEE displays each application’s
standard and error output in an Emacs command interface (comint) buffer.
You can interact with applications that accept command line input via
the comint buffer.  When interacting with an application, you can use
any of comint-mode’s extensive set of command-line history commands to
speed interaction.

   To run an application, enter ‘M-x jdee-run’ or select Java->Run App
from the Emacs menubar or type ‘C-c C-v C-r’.

* Menu:

* Specifying the Application's Main Class::
* Specifying a Startup Directory::
* Setting VM Command-Line Arguments::
* Setting Command-Line Application Arguments::
* Navigating Exception Traces::
* Run Customization Variables::


File: jdee.info,  Node: Specifying the Application's Main Class,  Next: Specifying a Startup Directory,  Prev: Running Java Applications,  Up: Running Java Applications

1.12.1 Specifying the Application’s Main Class
----------------------------------------------

The term main class refers to the class that contains the application’s
main method.  The JDEE’s Run App command assumes by default that the
class in the current buffer is the application’s main class.  This can
be inconvenient if you have an application that has multiple classes.
You may want to be able to run the application from any buffer
containing one of the application’s classes.  To do this, set the
variable jdee-run-application-class to the fully qualified name of the
application’s main class.

   You can temporarily override the setting of
jdee-run-application-class by typing C-u - before executing the jdee-run
command, for example, by typing C-u - C-c C-r.  This causes the JDEE to
prompt you to enter the fully qualified name of the application’s main
class (as well application arguments if any).


File: jdee.info,  Node: Specifying a Startup Directory,  Next: Setting VM Command-Line Arguments,  Prev: Specifying the Application's Main Class,  Up: Running Java Applications

1.12.2 Specifying a Startup Directory
-------------------------------------

The JDEE can start an application from any directory that you specify.
By default, the JDEE starts an application from the default directory of
the current source buffer.  The default directory of the current source
buffer is the directory containing the source file displayed in the
buffer.  You can specify another directory as the startup directory by
setting the JDEE customization variable jdee-run-working-directory.

   To set this variable,
  1. Display its customization panel.

     You can do this by typing ‘M-x customize-variable
     jdee-run-working-directory’ or selecting JDEE->Options->Project to
     display the project customization panel and searching this panel
     for jdee-run-working-directory.

  2. Enter the working directory in the variable’s edit field.

  3. Save the new setting.

     To save the edited bindings, right click the [State] button and
     choose Set for current session if you want the settings to apply
     only to the current project or Save for future sessions if you want
     the settings to apply to all projects.  In either case, you should
     save the new settings in you project file if your project has a
     project file.  To save the new settings in your project file,
     switch to a source buffer and choose JDEE->Options->Save Project.


File: jdee.info,  Node: Setting VM Command-Line Arguments,  Next: Setting Command-Line Application Arguments,  Prev: Specifying a Startup Directory,  Up: Running Java Applications

1.12.3 Setting VM Command-Line Arguments
----------------------------------------

If you set the customization variable jdee-run-read-vm-args to a non-nil
value, the JDEE compile command prompts you to enter virtual machine
options in the minibuffer.  It appends the options that you enter to the
options specified via customization variables.  The JDEE saves the
arguments that you enter in a minibuffer history list.  You can recall
previously entered options by pressing the up or down arrows on your
keyboard.


File: jdee.info,  Node: Setting Command-Line Application Arguments,  Next: Navigating Exception Traces,  Prev: Setting VM Command-Line Arguments,  Up: Running Java Applications

1.12.4 Setting Command-Line Application Arguments
-------------------------------------------------

Specifying a prefix argument before the jdee-run, e.g., C-u C-c C-v C-r
causes the command to prompt you to enter arguments to be passed to the
application’s main method.  The command appends the options that you
enter to the arguments specified via the customization variable
jdee-run-option-application-args.  The JDEE saves the arguments that you
enter in a minibuffer history list.  You can recall previously entered
options by pressing the up or down arrows on your keyboard.

   If you set the customization variable jdee-run-read-app-args to a
non-nil value, the JDEE run command prompts you to enter command-line
application arguments by default, i.e., you do not have to specify a
prefix argument each time you execute the command.


File: jdee.info,  Node: Navigating Exception Traces,  Next: Run Customization Variables,  Prev: Setting Command-Line Application Arguments,  Up: Running Java Applications

1.12.5 Navigating Exception Traces
----------------------------------

If an exception occurs while your program is running, the JVM outputs an
exception trace.  This trace appears in the run buffer for the
application.

   To view the source line corresponding to a point in the exception
stack trace, right-click the corresponding stack trace line in the run
buffer.  You can move up and down the stack trace by typing the key
combinations ‘C-c C-v C-[’ or ‘C-c C-v C-]’.


File: jdee.info,  Node: Run Customization Variables,  Prev: Navigating Exception Traces,  Up: Running Java Applications

1.12.6 Run Customization Variables
----------------------------------

The JDEE allows you to specify run-time options by setting run
variables.  You can use the Emacs customization feature to set run-time
variables interactively.  To use the customization feature, select
JDEE->Project->Options->Run.  (See Configuring the JDEE for more
information on using the customization feature).  To save the
compilation settings in the project file (see Using Project Files) for
the current source buffer, select JDEE-> Project->Project File->Save
Project.

   The following table lists the JDEE run variables and the functions
used to set them.

Variable                             Group   Usage
---------------------------------------------------------------------------
jdee-run-mode-hook                   Project List of hook functions run
                                             by jdee-run-mode
jdee-run-working-directory           Project Startup directory for
                                             running or debugging Java
                                             applications.
jdee-run-application-class           Project Name of the Java class to
                                             run.  The command
                                             jdee-run-set-app sets the
                                             buffer-local value of this
                                             variable.
jdee-run-java-vm                     Project Specify Java interpreter
                                             for non-Windows platforms.
                                             The command jdee-run-set-vm
                                             sets the buffer-local value
                                             of this variable.
jdee-run-java-vm-w                   Project Specify Java interpreter
                                             for Windows platforms.  The
                                             command jdee-run-set-vm-w
                                             sets the buffer-local value
                                             of this variable.
jdee-global-classpath                Project Specify class paths for
                                             compile, run, and debug
                                             commands.  The command
                                             jdee-set-global-classpath
                                             sets the buffer-local value
                                             of this variable.
jdee-run-classic-mode-vm             Project Specifies that the JDEE
                                             should run the JDK’s
                                             classic version of the Java
                                             virtual machine (as opposed
                                             to the HotSpot version).
                                             This option applies only to
                                             versions of the JDK that
                                             include both a classic and
                                             a HotSpot vm.
jdee-run-read-vm-args                Project Specifies whether to read
                                             vm arguments from the
                                             minibuffer.
jdee-run-option-classpath            Run     Specifies the classpath for
                                             the Java interpreter.  This
                                             option overrides the
                                             jdee-global-classpath
                                             option.
jdee-run-option-verbose              Run     Print messages about the
                                             running process.
jdee-run-option-properties           Run     Specify property values.
jdee-run-option-heap-size            Run     Specify the initial and
                                             maximum size of the
                                             interpreter heap.
jdee-run-option-stack-size           Run     Specify size of the C and
                                             Java stacks.
jdee-run-option-garbage-collection   Run     Specify garbage collection
                                             options.
jdee-run-option-java-profile         Run     Enable Java profiling.
jdee-run-option-heap-profile         Run     Output heap profiling data.
jdee-run-option-verify               Run     Verify classes.
jdee-run-option-vm-args              Run     Specify command-line
                                             arguments to be passed to
                                             the Java vm.  The command
                                             jdee-run-set-args sets the
                                             buffer-local value of this
                                             variable.
jdee-run-option-application-args     Run     Specify command-line
                                             arguments to pass to the
                                             application.  The command
                                             jdee-run-set-app-args sets
                                             the buffer-local value of
                                             this variable.


File: jdee.info,  Node: Working with Applets,  Next: Debugging Applications,  Prev: Running Java Applications,  Up: User's Guide

1.13 Working with Applets
=========================

The JDEE provides specialized commands for running and debugging
applets.

* Menu:

* Running Applets::
* Debugging Applets::
* Applet Customization Variables::


File: jdee.info,  Node: Running Applets,  Next: Debugging Applets,  Prev: Working with Applets,  Up: Working with Applets

1.13.1 Running Applets
----------------------

To run an applet:
  1. Open the applet’s source file in a buffer.

  2. Choose JDEE->Run Applet.

     The JDEE searches for an html file in the directory containing the
     applet source file and displays the first file it finds, using your
     system’s default browser.  If the JDEE cannot find an html page in
     the applet’s source file directory, it signals an error by default.

   The JDEE->Run Applet command assumes by default that the directory
containing the applet’s source also contains an html page for testing
that applet.  If this is not true in your case, you have two options.
You can either specify the path of the applet file via the JDEE
customization variable jdee-run-applet-doc or you can use the
jdee-run-applet command to run your applet.  If the jdee-run-applet-doc
variable is not a null string, JDEE->Run Applet displays the document
that the variable specifies instead of searching the source file
directory for a document to display.  The jdee-run-applet command
prompts you to enter in the minibuffer the path of an html file to
display.  If you enter nothing, the command defaults to the behavior of
JDEE->Run Applet.

   The run commands chooses the viewer as follows.  If
jdee-run-applet-viewer is a null string (the default) or browse-url, the
JDEE uses browse-url to launch the applet doc in your system’s default
browser.  Otherwise, the menu command uses comint to launch the viewer
(e.g., appletviewer) specified by jdee-run-applet-viewer.


File: jdee.info,  Node: Debugging Applets,  Next: Applet Customization Variables,  Prev: Running Applets,  Up: Working with Applets

1.13.2 Debugging Applets
------------------------

To debug an applet:
  1. Open the applet’s source file in a buffer.

  2. Choose JDEE->Debug Applet.

     The JDEE searches for an html file in the directory containing the
     applet source file.  If the JDEE cannot find an html page in the
     applet’s source file directory, it signals an error by default.
     Otherwise, it runs appletviewer in debug mode on the first file
     that it finds.

     The Emacs window splits into two panes.

   The top pane shows the applet’s source file with the debug cursor
pointing to the first line of the applet’s init file.  The bottom pane
displays the debugger’s command line interface.  You can now set
breakpoints, single-step, or continue running the applet.  See Debugging
Applications for more information.

   If you want to specify the document to be used to test the applet,
customize the variable jdee-run-applet-doc or execute M-x
jdee-db-applet.  This command prompts you to enter the test document’s
name.


File: jdee.info,  Node: Applet Customization Variables,  Prev: Debugging Applets,  Up: Working with Applets

1.13.3 Applet Customization Variables
-------------------------------------

The JDEE allows you to specify run-time options for applets by setting
JDEE configuration variables.You must use the Emacs customization
feature to set applet run-time variables .  To use the customization
feature, select JDEE->Options->Run.  (See Configuring the JDEE for more
information on using the customization feature).  In some cases, the
JDEE also provides functions for setting the buffer-local values of the
compilation variables.  To save the compilation settings in the project
file (see Using Project Files) for the current source buffer, select
JDEE->Options->Update Project.

   The following table lists the JDEE applet run-time variables and the
functions used to set them (all are in Project group):

Variable               Usage
--------------------------------------------------------------------------
jdee-run-applet-viewer Specify name of viewer to use to display page
                       containing the applet.  The command
                       jdee-run-set-applet-viewer sets the buffer-local
                       value of this variable.
jdee-run-applet-doc    Specify name of document containing applet to be
                       viewed.  The command jdee-run-set-applet-doc
                       sets the buffer-local value of this variable.


File: jdee.info,  Node: Debugging Applications,  Next: Specifying Classpaths,  Prev: Working with Applets,  Up: User's Guide

1.14 Debugging Applications
===========================

The JDEE provides two options for debugging Java applications.

   • An Emacs interface to jdb, the command-line debugger that comes
     with the JDK. See Debugging with jdb for more information.

   • JDEbug, a Java debugger developed specifically for use with the
     JDE. See JDEbug User’s Guide for more information.

   JDEbug provides more debugging features but requires a JDK 1.2 or
higher vm.  You must use jdb to debug applications running on earlier
VMs.


File: jdee.info,  Node: Specifying Classpaths,  Next: Using Project Files,  Prev: Debugging Applications,  Up: User's Guide

1.15 Specifying Classpaths
==========================

The JDEE provides customization variables that permit you to specify a
classpath for the JDE’s compile, run, debug, Beanshell, and other
commands.  The following table lists these variables.

Variable                      Applies to
--------------------------------------------------------------------------
jdee-global-classpath         All JDEE commands that use a classpath.
jdee-compile-option-classpath Compile command
jdee-run-option-classpath     Run App command
jdee-db-option-classpath      Debug App command

   The jdee-global-classpath variable is so named because it specifies a
classpath that is used by all JDEE commands unless overridden by a
classpath variable specific to a particular command.  For example, the
JDE’s Compile command uses jdee-global-classpath unless the value of
jdee-compile-option-classpath is set.  Typically you want to use the
same classpath to compile, run, and debug an application.  So typically
jdee-global-classpath is the only variable you need to set.

* Menu:

* Setting a Classpath Variable::
* Including Class Libraries::


File: jdee.info,  Node: Setting a Classpath Variable,  Next: Including Class Libraries,  Prev: Specifying Classpaths,  Up: Specifying Classpaths

1.15.1 Setting a Classpath Variable
-----------------------------------

As with other JDEE customization variables, you must use Emacs’
customize-variable command to set the JDE’s classpath variables.  You
can use relative paths, cygwin paths, and paths with tilde notation and
environment variables as values of JDEE classpath variables.  See
Specifying Paths for more information.

   When setting a classpath variable, you must enter each path as a
separate entry in the customization buffer.  Do not enter the paths as
semicolon or colon-separated lists of paths.  The following examples
show the right and wrong way to specify a classpath.

   Example 1.  Wrong Way to Specify a Classpath

     jdee-global-classpath: [Hide]
     [INS] [DEL] Path: c:/jdee-dev/jmath/classes;c:/jdee-dev/jmath/src
     [INS]
       [State]: this option has been set and saved.

   Example 2.  Right Way to Specify a Classpath

     jdee-global-classpath: [Hide]
     [INS] [DEL] Path: c:/jdee-dev/jmath/classes
     [INS] [DEL] Path: c:/jdee-dev/jmath/src
     [INS]
       [State]: this option has been set and saved.


File: jdee.info,  Node: Including Class Libraries,  Prev: Setting a Classpath Variable,  Up: Specifying Classpaths

1.15.2 Including Class Libraries
--------------------------------

If you store your class libraries as jar or zip files in separate
directory, you need specify only the path of the directory in a JDEE
classpath variable.  Whenever the JDEE encounters a library directory in
a classpath variable, it expands the classpath to include all the jar
and zip files in the library directory.

   For example, suppose you organize your project directory as follows:

     myproj classes lib
              src

   where the src directory contains all of your source files, the lib
directory all of your jar and zip files, and the classes directory all
of the classes compiled from the src directory.  Further, suppose you
store your project file (see Using Project Files) at the root of your
project directory.  Then, you can specify jdee-global-classpath simply
as follows.

     jdee-global-classpath:
               [Hide] [INS] [DEL] Path: ./classes [INS] [DEL] Path: ./src
               [INS] [DEL] Path: ./lib [INS] [State]: this option has been
               set and saved.

   If you do not want the JDEE to expand library directories, set the
variable jdee-expand-classpath-p off.  The JDEE expands directories
whose names match the regular expressions specified by
jdee-lib-directory-names.  The default values of this variable are ^lib
and ^jar.  So by default, the JDEE expands names that begin with the
string lib or lib, e.g., lib, libraries, etc.  However, you can
customize jdee-lib-directory-names to reflect any library naming scheme
you prefer.


File: jdee.info,  Node: Using Project Files,  Next: Displaying Java Documentation,  Prev: Specifying Classpaths,  Up: User's Guide

1.16 Using Project Files
========================

A project file is a Lisp file that the JDEE loads and evaluates whenever
you open a Java source file belonging to a specific project.  The JDEE
has commands that save the current settings of JDEE project variables in
the project file for the current project.  Project files thus allow you
to save and restore project-specific settings of JDEE customization
variables.  For example, you can use a project file to set the value of
the jdee-global-classpath variable to a project-specific classpath
automatically whenever you load a file belonging to that project.

* Menu:

* How the JDEE Finds Project Files::
* Project File Contents::
* Creating a Project File::
* Creating Portable Projects::
* Disabling Context Switching::
* Project Hook Functions::


File: jdee.info,  Node: How the JDEE Finds Project Files,  Next: Project File Contents,  Prev: Using Project Files,  Up: Using Project Files

1.16.1 How the JDEE Finds Project Files
---------------------------------------

To simplify the task of finding project files, the JDEE makes two
assumptions.  First, it assumes that all Java source files relating to a
particular project live in a single directory tree.  Second, it assumes
that all project files have the same file name.  The name assumed by
default is prj.el.  You can use the JDEE configuration variable
jdee-project-file-name to specify another name.

   When you open a Java source file, the JDEE looks for project files in
the directory tree containing the source file.  If the JDEE finds one or
more project files, it loads the project files in the following manner.

   The JDEE first sets all the JDEE variables to their Emacs startup
values (i.e., the default value or the value saved in your .emacs file).
It then loads all the project files in the directory tree containing the
current source buffer, starting with the topmost file.

   What this means is that you can use project files to extend and/or
override the settings in your .emacs file and in other project files.
For example, your .emacs file can specify settings that are common to
all your projects.  You can put settings common to a group of projects
at the top of the directory tree containing the projects, settings
common to each project at the top of the directory containing each
projects, and so on.


File: jdee.info,  Node: Project File Contents,  Next: Creating a Project File,  Prev: How the JDEE Finds Project Files,  Up: Using Project Files

1.16.2 Project File Contents
----------------------------

A project file can contain any Lisp code that can be evaluated correctly
as the last step in creating a Java source buffer.  For example, a
project file can contain code that sets the value of JDEE configuration
variables.  In general, a project file can contain any code that could
be implemented as a jdee-mode hook function.  In fact, you can think of
a project file as a project-specific jdee-mode hook function.


File: jdee.info,  Node: Creating a Project File,  Next: Creating Portable Projects,  Prev: Project File Contents,  Up: Using Project Files

1.16.3 Creating a Project File
------------------------------

The easiest way to create a project file is to use the
jdee-create-new-project command (JDEE->Project->Project File->Create
New).  This command creates a new project file and saves the current
values of all customized JDEE configuration variables in the project
file for the selected Java buffer.  (To be precise, the command inserts
Lisp code in the project file that restores the current settings of the
configuration variables; if such code already exists in the file, it
replaces it with updated code.)  Thus, to create a project file that
sets JDEE configuration variables to project-specific values:

  1. Open any source file belonging to the project.

  2. Set the values of the JDEE configuration variables to the
     appropriate values for the project to which the source file
     belongs.

  3. See Configuring the JDEE for information on how to set the values
     of the JDEE configuration variables.

  4. Select JDEE->Project->Project File->Save Project.

  5. The JDEE prompts you to enter the path to a directory in which to
     store the project file.

  6. Enter the directory where you want to store the project file or
     press Enter to store the project file in the current directory.

   Once you have created the project file, you can insert additional
configuration code into the file if desired.  Note that the
jdee-save-project command edits rather than replaces existing project
files.  Thus, you can use the command to update configuration variable
settings without disturbing any other configuration code that you have
inserted manually into the project file.


File: jdee.info,  Node: Creating Portable Projects,  Next: Disabling Context Switching,  Prev: Creating a Project File,  Up: Using Project Files

1.16.4 Creating Portable Projects
---------------------------------

You can use relative paths and environment variables to construct
portable project files.  For example, suppose your project directory has
the following structure:

     myprj
       classes
         pkg1
         pkg2
       src
         pkg1
         pkg2
       prj.el

   Further suppose that your project uses beans from a shared library
specified by the environment variable BEANS. With this setup, you can
specify jdee-global-classpath as:

     ./src
     ./classes
     $BEANS/lib/dials.jar

   and jdee-compile-option-directory as

     ./classes

   This causes the JDEE to store classes compiled from your src
directory in the classes directory.  Note that you have not used any
absolute paths in creating your project file.  This means you can move
your project anywhere without having to update the project file.


File: jdee.info,  Node: Disabling Context Switching,  Next: Project Hook Functions,  Prev: Creating Portable Projects,  Up: Using Project Files

1.16.5 Disabling Context Switching
----------------------------------

When you select a buffer that belongs to another project, the JDEE loads
the project file for that project and may update the class list for the
project.  This causes a slight delay before you can begin using the new
buffer.  The delay can be irritating if you need to switch frequently
among open projects, for example, when copying or diffing code from
different projects.  Accordingly, the JDEE provides ways for you to
disable context-switching either permanently or temporarily.

   To disable context-switching permanently, toggle the customizat
variable jdee-project-context-switching-enabled-p off.  Be sure to use
customize to do this and save the customization in your .emacs or prj.el
file.  Note that you can use the JDE’s project file loading command,
JDEE->Project->Project File->Load, to switch contexts manually.

   To disable context-switching temporarily during a session, select
JDEE->Project->Auto Switch or enter M-x
jdee-toggle-project-context-switching.  To reenable context-switching,
execute the same command again.


File: jdee.info,  Node: Project Hook Functions,  Prev: Disabling Context Switching,  Up: Using Project Files

1.16.6 Project Hook Functions
-----------------------------

The variable jdee-project-hooks lists functions that execute after the
JDEE loads a project file.  By writing hook functions and adding them to
this list, you can specify actions to be taken every time the JDEE
switches from one project to another.


File: jdee.info,  Node: Displaying Java Documentation,  Next: Browsing Source Code,  Prev: Using Project Files,  Up: User's Guide

1.17 Displaying Java Documentation
==================================

The JDEE provides commands for displaying the JDK API documentation and
context-sensitive help for classes.

* Menu:

* Browsing JDK Documentation::
* Context-Sensitive Class Help::
* Specifying a Browser::


File: jdee.info,  Node: Browsing JDK Documentation,  Next: Context-Sensitive Class Help,  Prev: Displaying Java Documentation,  Up: Displaying Java Documentation

1.17.1 Browsing JDK Documentation
---------------------------------

The jdee-browse-jdk-doc command (JDEE->Help->JDK, C-c C-v C-n) opens the
JDK documentation in a browser.  By default, this command displays the
JDK documentation page at JavaSoft’s web site.  To display a different
copy, set the variable jdee-jdk-doc-url to the url of the index page of
the copy you want to be displayed.


File: jdee.info,  Node: Context-Sensitive Class Help,  Next: Specifying a Browser,  Prev: Browsing JDK Documentation,  Up: Displaying Java Documentation

1.17.2 Context-Sensitive Class Help
-----------------------------------

The JDK provides context-sensitive help for Java classes.  To use this
facility, you must first customize the variable jdee-help-docsets to
specify the location of class documentation on your system.  The JDEE
class help facility supports javadoc documentation by default but it
works with other types of documentation as well.

   Once you have specified the location of class documentation on your
system, you can get help for the class at point in the current buffer by
selecting JDEE->Help->Symbol at Point.


File: jdee.info,  Node: Specifying a Browser,  Prev: Context-Sensitive Class Help,  Up: Displaying Java Documentation

1.17.3 Specifying a Browser
---------------------------

The JDEE uses the browsers or browsers specified by the customization
variable browse-url-browser-function.  See the documentation for this
variable for more information.

* Menu:

* Using emacs-w3m to Browse Java Doc::


File: jdee.info,  Node: Using emacs-w3m to Browse Java Doc,  Prev: Specifying a Browser,  Up: Specifying a Browser

1.17.3.1 Using emacs-w3m to Browse Java Doc
...........................................

The emacs-w3m package uses the w3m text-mode HTML browser to enable
Emacs to render text HTML pages.  This allows you to use Emacs not only
to develop Java code but also to browse Java API and tools
documentation.  For information on downloading and installing emacs-w3m
and w3m, see the emacs-w3m web site.

   While you’re at it, you should also install the WThreeM package.
This package provides incremental searching on URLs in w3m HTML buffers,
a nice feature for browsing Javadoc class documentation, with its wealth
of links.

   One you have installed emacs-w3m/w3m, you can configure Emacs (and
hence the JDEE) to use it to display Javadoc pages by customizing
jdee-help-browser-function to specify w3m-browse-url.

   The w3m-browse-url function displays its output by default in the
current window, replacing the Java file in the buffer.  To cause the
function to display its output in a popup window, customize
w3m-pop-up-frames.


File: jdee.info,  Node: Browsing Source Code,  Next: Searching Source Code,  Prev: Displaying Java Documentation,  Up: User's Guide

1.18 Browsing Source Code
=========================

* Menu:

* Classes Index Menu::
* Using the Speedbar::
* Tags::


File: jdee.info,  Node: Classes Index Menu,  Next: Using the Speedbar,  Prev: Browsing Source Code,  Up: Browsing Source Code

1.18.1 Classes Index Menu
-------------------------

The Classes index menu appears by default in the Emacs menubar whenever
a Java source buffer is active.  The menu consists of a cascading list
of all classes, methods, fields, and imports defined in the current
buffer plus the package to which the current buffer belongs.  Selecting
any item scrolls the buffer to the statement that defines the item.

   The top-level menu contains an entry for each each class defined by
the active buffer followed by entries for the imports and package of the
current buffer.  Selecting the entry for a class displays a submenu
listing the inner classes, methods, and fields defined by the class.
Selecting the entry for an inner class displays another submenu for that
class, and so on.  Selecting the imports entry on the top-level menu
displays a submenu listing all the classes and packages imported by the
active buffer.

* Menu:

* Special Index Entries::
* Alphabetizing the Classes Menu::
* Suppressing Method Signatures and Field Types::
* Disabling the Classes Menu::
* Using the Keyboard to Navigate the Classes Menu::


File: jdee.info,  Node: Special Index Entries,  Next: Alphabetizing the Classes Menu,  Prev: Classes Index Menu,  Up: Classes Index Menu

1.18.1.1 Special Index Entries
..............................

The index menu includes the following special index entries:

   • *Rescan*

     Selecting this item causes the JDEE to rebuild the index menu.  You
     should rebuild the menu whenever you edit the buffer.

   • *class def*

     Selecting this item takes you to the start of the definition of the
     class on whose submenu it appears.  Turn the variable
     jdee-imenu-include-classdef off to suppress inclusion of these
     items in the menu.


File: jdee.info,  Node: Alphabetizing the Classes Menu,  Next: Suppressing Method Signatures and Field Types,  Prev: Special Index Entries,  Up: Classes Index Menu

1.18.1.2 Alphabetizing the Classes Menu
.......................................

By default the Classes menu lists methods and fields in the order in
which the active buffer defines them.  Use the variable jdee-imenu-sort
to customize the menu to list methods and fields alphabetically in
either ascending or descending order.


File: jdee.info,  Node: Suppressing Method Signatures and Field Types,  Next: Disabling the Classes Menu,  Prev: Alphabetizing the Classes Menu,  Up: Classes Index Menu

1.18.1.3 Suppressing Method Signatures and Field Types
......................................................

By default the Classes menu displays the signatures of methods and the
types of fields displayed in the active buffer.  The method signatures
enable you to distinguish overloaded method names.  The menu can also
display the names of methods and fields without signatures and types.
Use the variable jdee-imenu-include-signature to turn signature and type
display off or on.


File: jdee.info,  Node: Disabling the Classes Menu,  Next: Using the Keyboard to Navigate the Classes Menu,  Prev: Suppressing Method Signatures and Field Types,  Up: Classes Index Menu

1.18.1.4 Disabling the Classes Menu
...................................

Set the variable jdee-imenu-enable off to disable the Classes menu.
When disabled, the menu does not appear in the Emacs menubar.


File: jdee.info,  Node: Using the Keyboard to Navigate the Classes Menu,  Prev: Disabling the Classes Menu,  Up: Classes Index Menu

1.18.1.5 Using the Keyboard to Navigate the Classes Menu
........................................................

Execute M-x imenu to use the keyboard to navigate the Classes menu.
Emacs displays the top-level items on the Classes menu in a buffer and
prompts you to enter the name of an an item in the minibuffer.  Enter
the name of the item to select it.  Note that you can use completion to
avoid having to type the whole name.  If you select a submenu, Emacs
displays the contents of the submenu and prompts you to enter a
selection in the keyboard.  If you select an index entry, Emacs scrolls
the buffer to the indexed point in the buffer.


File: jdee.info,  Node: Using the Speedbar,  Next: Tags,  Prev: Classes Index Menu,  Up: Browsing Source Code

1.18.2 Using the Speedbar
-------------------------

To display the speedbar, select JDEE-> Speedbar.  The speedbar opens in
a separate frame.

   The speedbar displays a list of the files and subdirectories in the
directory containing the file displayed in the current buffer.  The
speedbar highlights the file displayed in the current buffer.

   Click on the expand (+) button in front of any file.  The node for
the file expands to show up to three entries, depending on the contents
of the source file.

* Menu:

* Package::
* Types::
* Dependencies::
* Updating the Speedbar::


File: jdee.info,  Node: Package,  Next: Types,  Prev: Using the Speedbar,  Up: Using the Speedbar

1.18.2.1 Package
................

This item expands to show the package to which the file belongs.

   Clicking on the package scrolls the buffer to the corresponding
package declaration.


File: jdee.info,  Node: Types,  Next: Dependencies,  Prev: Package,  Up: Using the Speedbar

1.18.2.2 Types
..............

This item expands to show the classes in the selected file.

   Each class expands to show the constructors, methods, fields, and
inner classes defined by the class and the class’s parent, if any.
Inner classes also expand and their inner classes, and so on.  The
constructors and methods expand to show arguments and argument types and
return types.  Fields expand to show their type.

   Clicking on any class, inner class, method, constructor, or field
scrolls the buffer to show that item.


File: jdee.info,  Node: Dependencies,  Next: Updating the Speedbar,  Prev: Types,  Up: Using the Speedbar

1.18.2.3 Dependencies
.....................

This item expands to show the classes and packages imported by the
current source file.

   Click on class or package to scroll the buffer to the corresponding
import statement.


File: jdee.info,  Node: Updating the Speedbar,  Prev: Dependencies,  Up: Using the Speedbar

1.18.2.4 Updating the Speedbar
..............................

If you make changes to a source buffer, you must update the speedbar
view to reflect the changes.  To update the speedbar view of a buffer:

  1. Collapse the speedbar view of the buffer.

  2. This is necessary only if the speedbar view is expanded.  To
     collapse the speedbar view, click the collapse button (-) next to
     the buffer’s file name in the speedbar view.

  3. Hold the shift key down while clicking the expand button (+) next
     to the buffer’s name in the speedbar view.


File: jdee.info,  Node: Tags,  Prev: Using the Speedbar,  Up: Browsing Source Code

1.18.3 Tags
-----------

To use the etags facility, you must first construct a TAGS file that
indexes every symbol in your source code.  The JDEE package contains two
shell scripts that you can use to tag your source code, one for csh
shells and the other for bash.  The bash version is called jtags; the
csh version, jtags.csh.

* Menu:

* Tagging Java Source Code::
* Finding the Definition of a Symbol::


File: jdee.info,  Node: Tagging Java Source Code,  Next: Finding the Definition of a Symbol,  Prev: Tags,  Up: Tags

1.18.3.1 Tagging Java Source Code
.................................

To tag your source code, first copy the appropriate shell script to a
directory in your Emacs path.  Then start a shell (M-x shell).  Change
to the top-level directory containing your source code and then enter
jtags.  The jtags script tags every .java file in the current directory
and in all descendants of the current directory, storing the result in a
file called TAGS in the top-level directory.


File: jdee.info,  Node: Finding the Definition of a Symbol,  Prev: Tagging Java Source Code,  Up: Tags

1.18.3.2 Finding the Definition of a Symbol
...........................................

To find the definition of a symbol, put your cursor anywhere in the
symbol and enter M-..  Emacs responds by locating and opening (if
necessary) the file containing the definition and positioning the point
at the definition.  (The first time you type M-., Emacs prompts you to
load the TAGS file.)


File: jdee.info,  Node: Searching Source Code,  Next: Customizing the JDEE,  Prev: Browsing Source Code,  Up: User's Guide

1.19 Searching Source Code
==========================

The JDEE provides commands that enable you to find:

   • All occurences of strings matching a regular expression anywhere in
     your project’s source path (see Finding Expressions)

   • Source code that defines the method, field, or other symbol at
     point (see Finding Symbol Definitions)

   • Source code for the class at point (see Finding Classes)

   • Source for the parent of the class at point

   • Source for an interface implemented by the class at point

   • All methods that invoke a specifed method (see Cross-Referencing
     Classes)

* Menu:

* Finding Expressions::
* Finding Symbol Definitions::
* Finding Classes::
* Cross-Referencing Classes::


File: jdee.info,  Node: Finding Expressions,  Next: Finding Symbol Definitions,  Prev: Searching Source Code,  Up: Searching Source Code

1.19.1 Finding Expressions
--------------------------

The JDEE provides two commands for finding occurrences of strings in
Java source and other types of text files:

   • JDEE->Find->Expression (jdee-find)

     This command uses the minibuffer to prompt you for the search
     expression and the paths to be searched.  You can use customization
     variables to specify values for the search paths and other search
     options.  The default values for the customization variables search
     the Java source files on the classpaths and sourcepaths for your
     project.  See Using the Minibuffer-Based Find Command for more
     information.

   • JDEE->Find->Expression...  (jdee-find-dlg)

     This command uses a text dialog buffer to prompt you for search
     arguments.  The dialog buffer allows you to specify all search
     options interactively.  It is thus useful for performing searches
     that have special requirements.  See Using the Dialog-Based Find
     Command for more information.

   Both commands use the Unix grep and find utilities to perform the
searches that you specify.  Before executing a search, both commands
search your system for copies of grep and find and signal an error if
the utilities are missing.  All Unix systems include copies of grep and
find.  Versions of these utilities are available for Microsoft Windows,
e.g., as part of the Cygwin Unix emulation package for Microsoft
Windows.  If you want to use the JDEE’s find commands on Windows, you
must install copies of grep and find on your system and either include
them in your system’s command path or use the variables grep-command and
find-program to specify their respective locations on your system.

     Note: Microsoft Windows provide a find utility that is incompatible
     with the Unix find utility.  To ensure that the JDEE finds the
     right version, you should either put the Unix-style find command
     ahead of the Windows find command in your system command path or
     use the find-program variable to specify the Unix-style command’s
     location.

* Menu:

* Using the Minibuffer-Based Find (jdee-find) Command::
* Customizing the Minibuffer-Based Find Command::
* Using the Dialog-Based Find (jdee-find-dlg) Command::


File: jdee.info,  Node: Using the Minibuffer-Based Find (jdee-find) Command,  Next: Customizing the Minibuffer-Based Find Command,  Prev: Finding Expressions,  Up: Finding Expressions

1.19.1.1 Using the Minibuffer-Based Find (jdee-find) Command
............................................................

To find an expression with the minibuffer-based find command:

  1. Select Find->Expression (C-c-C-v-C-f) from the JDEE menu or execute
     the jdee-find command.

     The JDEE prompts you to enter a regular expression.

  2. Enter a regular expression that matches the expressions you want to
     find and press Enter.

     The JDEE prompts you to enter a list of directories to search.

     The prompt may list a default search path.  The JDEE determines the
     default path by testing each of the following variables in the
     order listed.
        • jdee-sourcepath
        • jdee-compile-option-sourcepath
        • jdee-compile-option-classpath
        • jdee-global-classpath

     The JDEE uses the directories specified by the first path variable
     that has a nonnil value as the default search path.

  3. Edit the default search path, if desired, in the minibuffer and
     press Enter.

     The JDEE executes the find command that you have specified and
     displays the command’s output in a popup grep-mode buffer.

   The search results buffer lists each instance of a string that
matches the specified regular expression in the specified search path.
For each match, the listing shows the file and line number of the match,
highlighted in red, and a snippet of the text in which the match
occurred.

   To visit the file containing the match, click the match message in
the grep buffer with the middle mouse button or move point to the
message and press Enter.


File: jdee.info,  Node: Customizing the Minibuffer-Based Find Command,  Next: Using the Dialog-Based Find (jdee-find-dlg) Command,  Prev: Using the Minibuffer-Based Find (jdee-find) Command,  Up: Finding Expressions

1.19.1.2 Customizing the Minibuffer-Based Find Command
......................................................

The following variables allow you to customize the minibuffer-based
search command:

Variable                  Default   Description
---------------------------------------------------------------------------
jdee-find-case-sensitive  nil       Specifies whether the jdee-find
                                    command performs a case-sensitive
                                    search.  If non-nil, the search is
                                    case-sensitive; otherwise the search
                                    ignores case.
jdee-find-granularity     Character Specifies the granularity of the
                                    expression search conducted by
                                    jdee-find: Character (expression
                                    starting on any character), Word
                                    (match words only), Line (match
                                    lines only).
jdee-find-file-regexp     *.java    Specifies the regular expression
                                    that the jdee-find command uses to
                                    select files to be searched.  You
                                    can use any regular expression
                                    supported by the -name option of the
                                    GNU find command.


File: jdee.info,  Node: Using the Dialog-Based Find (jdee-find-dlg) Command,  Prev: Customizing the Minibuffer-Based Find Command,  Up: Finding Expressions

1.19.1.3 Using the Dialog-Based Find (jdee-find-dlg) Command
............................................................

To find an expression with the dialog-based find command:

  1. Select Find->Expression...  from the JDEE menu or execute the
     jdee-find command.

     The Find Expression Options buffer appears.

  2. Edit the buffer to reflect the search options that you desire.

     Note: The options you select will appear the next time you execute
     the jdee-find-dlg command.

  3. Select the Ok button.

   The jdee-find-dlg invokes the find and grep commands with the options
you specified and displays the results in a buffer.


File: jdee.info,  Node: Finding Symbol Definitions,  Next: Finding Classes,  Prev: Finding Expressions,  Up: Searching Source Code

1.19.2 Finding Symbol Definitions
---------------------------------

To find the source code that defines the class, interface, method, or
field at point, select Find->Symbol Definition (C-c C-v C-y) from the
JDEE menu or execute M-x jdee-open-class-at-point.  The JDEE displays a
buffer containing the source code that defines the symbol at point in
the original buffer.

     Note: This command requires that the symbol definition be located
     on jdee-sourcepath and that the class referenced at point be
     located on jdee-global-classpath.  The command uses the beanshell
     to determine the fully qualified name of the class referenced at
     point.  If the beanshell is not running, it launches the beanshell.


File: jdee.info,  Node: Finding Classes,  Next: Cross-Referencing Classes,  Prev: Finding Symbol Definitions,  Up: Searching Source Code

1.19.3 Finding Classes
----------------------

The jdee-open-class-source command finds and opens the Java source file
for the class whose qualified or unqualified name appears at point.

     Note: The JDEE uses Java reflection to determine the fully
     qualified name of the class at point.  Therefore, the class must be
     on jdee-global-classpath.

   If more than one class with the same name exists on
jdee-global-classpath, this command prompts you to select one of the
classes.  The following conditions must be true for this command to
work.  First, a class file for this class must exist on the classpath
specified by jdee-global-classpath.  Secondly, the source for the class
must exist on one of the paths specified by jdee-sourcepath.  This
command uses the Beanshell to determine the fully qualified name of the
class to be found.  It starts the Beanshell if necessary.  Thus, the
command may respond somewhat slowly the first time you it in a session.


File: jdee.info,  Node: Cross-Referencing Classes,  Prev: Finding Classes,  Up: Searching Source Code

1.19.4 Cross-Referencing Classes
--------------------------------

JDEE includes a facility for creating and utilizing a cross-referencing
database to enable you to quickly locate all the callers of any
particular function.  This functionality is very useful for quickly
figuring how unfamiliar code works, and useful for doing certain tasks
such as renaming functions.  Be advised that this only finds direct
callers, and cannot detect calls via Java’s reflection mechanism.  The
cross-reference database must be kept in sync with the project code,
however the database generation is generally quick.  The remainder of
this section explains how to configure and use the cross-referencer.

   Thanks to Andrew Hyatt for developing the JDEE’s cross-referencing
facility.

* Menu:

* Configuring the Cross-Referencer::
* Building the Cross-Reference Database::
* Using the Cross-Reference Database::
* Updating the Cross-Reference Database::


File: jdee.info,  Node: Configuring the Cross-Referencer,  Next: Building the Cross-Reference Database,  Prev: Cross-Referencing Classes,  Up: Cross-Referencing Classes

1.19.4.1 Configuring the Cross-Referencer
.........................................

JDEE’s cross-referencing database is built by examining class files for
a particular project.  To this end, JDEE needs to know where the built
class files for a project live.  This is usually a subset of the
classpath.

   Then select JDEE->Options->Project->General, and go to the "Jde Built
Class Path" option.  Insert one path for each place where built classes
wind up.  You can add both directories and zip files (jar/bar/etc).  Any
file entered will be assumed to be a zip file.

   Now that you have the built class path defined, you can configure the
cross-referencer that uses it.  Type M-x jdee-xref-customize.  The
following are a list the variables that can be set, and what they do:

‘jdee-xref-db-base-directory’
     The cross-referencer creates a database to store the
     cross-reference information.  This variable defines a directory
     where that information resides.  It might, for example, be at the
     base of your project tree, in a directory called xrefdb.

‘jdee-xref-store-prefixes’
     To reduce database size, it’s useful to ignore all information that
     doesn’t refer to code you care about.  For example, most people
     don’t need to know who calls java.lang.System.out.println.  To not
     store this information, insert a package prefix for each package
     you are interested in.  Typically, this may be just one string, for
     example "com.mycompany", to store only code that references
     com.mycompany classes.

‘jdee-xref-cache-size’
     The caller database can be quite large.  However, it is useful for
     efficiency reasons to keep part of it in memory.  This variable
     deterines how many packages to keep in memory simulatenously.  The
     higher this is, the faster things will be, but also the more memory
     will be taken up by the cross-reference information.


File: jdee.info,  Node: Building the Cross-Reference Database,  Next: Using the Cross-Reference Database,  Prev: Configuring the Cross-Referencer,  Up: Cross-Referencing Classes

1.19.4.2 Building the Cross-Reference Database
..............................................

The next step into getting the cross-reference functionality working is
to build the cross-reference database.  The project must be fully built
for this to work, since it takes cross-reference information directly
from the built classes.

   To build the database, type ‘M-x jdee-xref-make-xref-db’.

   If all the settings are properly configured, JDEE will go off and
create the cross-reference database.  This can take from a few seconds
to several minutes depending on the size of your project.  Large class
files may take long to parse, so if it seems to be "stuck", please give
it time.

   When it is done, it will save the database in the base directory
specified in the jdee-xref customization group.


File: jdee.info,  Node: Using the Cross-Reference Database,  Next: Updating the Cross-Reference Database,  Prev: Building the Cross-Reference Database,  Up: Cross-Referencing Classes

1.19.4.3 Using the Cross-Reference Database
...........................................

There are several basic operations that use the cross-reference
database:

M-x jdee-xref-first-caller (C-c C-v a)
     If your cursor is in the body of a function, then this will go to
     the first in a sequence of callers to this function.  If there are
     no callers, there will be a message saying so.

M-x jdee-xref-next-caller (C-c C-v n)
     After calling jdee-xref-first-caller, you can go to each of the
     callers in sequence with this function.  The first caller function
     creates a list of callers and goes to the first one.  This
     navigates to the next caller on the list.  You can keep calling
     this until there are no more callers, in which case there will be a
     message saying so.

M-x jdee-xref-display-call-tree
     This displays an interactive tree view of the function you are in,
     and it’s callers.  Each level down will show you who calls the
     parent function.  In this way you can quickly get an overview of
     the context in which the current function is used in.  Each item in
     the tree will take you to it’s definition if it is clicked on.

M-x jdee-xref-list-uncalled-functions
     Called from a java file, this lists all the functions in the file
     that have no apparent callers.  It’s important to remember that
     because of Java reflection, there is no guarantee that the
     functions are truly uncalled.  It only means they are not called
     directly.

   All of these functions have two modes, a strict and non-strict mode.
In non-strict mode, the default, more potential callers are treated as
callers, including those that call an interface that the function
implements, or who call a superclass’s function you are overriding.  For
example, if you are in Foo.doSomething(), and foo implements IFoo, and a
caller calls IFoo.doSomething(), then this is treated as a caller in
non-strict mode.  Also, if you are in Foo.doSomething, and Foo’s
superclass is Bar, and there is a Bar.doSomething(), then
Bar.doSomething() is treated as a caller in non-strict mode.  In strict
mode, however, the caller must specify the function directly for it to
be considered a hit.  To run these functions with strict mode, type C-u
M-x and then the function-name.  So C-u M-x
jdee-xref-list-uncalled-functions will list only functions that are
uncalled directly.


File: jdee.info,  Node: Updating the Cross-Reference Database,  Prev: Using the Cross-Reference Database,  Up: Cross-Referencing Classes

1.19.4.4 Updating the Cross-Reference Database
..............................................

As the code changes, the cross-referencer must be kept up to date, or
else the jdee-xref functions will start taking you to incorrect places
in files, and the callers list itself will become incorrect.  As you
change the code, you can call M-x jdee-xref-update after a recompile,
and it will go through and recompute just the part of the database you
have changed.

   Another, easier way to update, for those of us who leave their emacs
running all the time, is to add a line such as this in their .emacs

     (run-at-time "11:00pm" 86400 'jdee-xref-make-xref-db)


File: jdee.info,  Node: Customizing the JDEE,  Next: Installing a Plugin,  Prev: Searching Source Code,  Up: User's Guide

1.20 Customizing the JDEE
=========================

This section describes various ways you can customize the JDEE.

* Menu:

* JDEE Customization Variables::
* Customizing jdee-mode::


File: jdee.info,  Node: JDEE Customization Variables,  Next: Customizing jdee-mode,  Prev: Customizing the JDEE,  Up: Customizing the JDEE

1.20.1 JDEE Customization Variables
-----------------------------------

JDEE customization variables allow you to specify compile, run, debug,
and other JDEE options.

     Note: The traditional way of customizing Emacs is to use setq forms
     to set the values of customization variables in the Emacs
     initialization (.emacs) file.  This method does not work for JDEE
     customization variables.  To set a JDEE customization variable, you
     must use the customization buffer for a variable (see the Emacs
     online manual for information on the customization feature).  This
     is because the JDEE context switching code resets all JDEE
     customization variables to their default or customized (via a
     custom buffer) values whenever you open a Java source file or
     switch projects.

   The following section explains how to use the Emacs customization
feature to set the value of a JDEE customization variable.

* Menu:

* Setting a Customization Variable::
* Specifying Paths::
* JDEE Customization Groups::


File: jdee.info,  Node: Setting a Customization Variable,  Next: Specifying Paths,  Prev: JDEE Customization Variables,  Up: JDEE Customization Variables

1.20.1.1 Setting a Customization Variable
.........................................

To set a JDEE customization variable:

  1. Determine the name of the variable you want to customize.

     Refer to the section of this guide that documents the feature you
     want to customize for the name of the corresponding variable.  Or
     type C-h v followed by the JDEE group prefix (jdee-) or subgroup
     prefix (e.g., jdee-compile-option-, see JDEE Customization Groups).
     Emacs displays all variables belonging to the JDEE group or
     subgroup.  You can then browse this list, using Emacs search,
     completion, and documentation display command, to find the
     applicable variable.

  2. Display a customization buffer for the variable.

     If you know the name of the variable, the easiest way to display a
     customization buffer for the variable is to select
     Help->Customize->Specific Option...  from the Emacs menubar or type
     M-x jdee-customize-variable.

     Note: jdee-customize-variable is a special version of the standard
     Emacs customize-variable command that provides a customization
     buffer menu item for saving a customization in a JDEE project file
     (see below).  You should use this version of the command if you
     intend to save customizations in project files.  You can also use
     it to do any other type of customization that the standard command
     supports.  This allows you to use the JDEE version of the command
     for all your customizations regardless of whether you intend to
     save them in project files.

     If you know the group to which the variable belongs (.e.g., compile
     options), you can display the customization buffer for the group.
     This is useful when you want to customize several related
     variables.  See JDEE Customization Groups for more information.

  3. Edit the value for the variable displayed in the customization
     buffer.

  4. Save the value for the variable in your .emacs or .prj file.

     If you want the setting to apply to all projects that do not have a
     project file (see Using Project Files), you should save the
     variable in your .emacs file.  To save the variable in your .emacs
     file, select Save for Future Sessions from the State menu for the
     variable in the customization buffer.

     If you want the setting to apply only to the current project,
     select Save in JDEE Project File from the State menu for the
     variable.

     Note: The Save in JDEE Project File menu item appears only if you
     used the jdee-customize-variable command to create the
     customization buffer.

     If a project file does not exist for the project, the JDEE prompts
     you to enter a name for the project.  It then creates a project
     file for the project with the name that you enter.


File: jdee.info,  Node: Specifying Paths,  Next: JDEE Customization Groups,  Prev: Setting a Customization Variable,  Up: JDEE Customization Variables

1.20.1.2 Specifying Paths
.........................

You can use paths containing environment variables and or a tilde (~),
cygwin paths, and relative paths as a value of any JDEE customization
variable that requires a path.

   _Environment Variables_

   The JDEE accepts paths that contain envirnoment variables, for
example,

     $JDK_HOME/src

   The JDEE replaces the environment variables with their actual values
before passing the paths to commands (e.g., javac) that require them.
You must use Unix notation (i.e., $VARNAME or ${VARNAME}) to specify an
environment variable in a path even on Windows.

   _Tilde (~) Notation_

   The JDEE accepts paths that begin with a tilde, for example,
~/myproj/classes.  The JDEE replaces the tilde with the path to your
home directory.

   _Relative Paths_

   A relative path is a path that begins with a period, for example,
./src.  If jdee-resolve-relative-paths is set to a non-nil value (the
default), the JDEE converts a relative path to an absolute path by
appending the relative path to the path of the project file that set the
path variable, or if no such file exists, to the path of the current
Java source buffer.

   You can use your .emacs file to specify default relative paths for
projects.  For example, setting jdee-global-classpath to ./classes in
your .emacs file specifies that the default location of class files is
in a subdirectory of the project file directory named classes.

   _Cygwin Paths_

   You can use cygwin style paths in JDEE classpath variables on
Windows.  The JDEE converts such paths to DOS paths before using them,
using a conversion function that you can specify.

   The jdee-cgywin-path-converter variable allows you to choose the path
conversion function used by the JDEE.

jdee-cygwin-path-converter-internal
     This is the default path conversion function used by the JDE. It
     converts any paths of the form //[a-z]/ or //cygdrive/[a-z]/ to the
     corresponding DOS form.  For example it converts
     /c/jde/java/classes to c:/jde/java/classes.

jdee-cygwin-path-converter-cygpath
     This function invokes the cygwin cygpath utility to perform the
     path conversion.  The advantage is that the cygwin path utility can
     recognize and convert Unix style paths that represent mount points
     in the cygwin mount table.  For example, suppose that you have
     mounted d:/javadev as /javadev in the cygwin mount table.  Then
     choosing jdee-cygwin-path-converter-cygpath allows you to use paths
     beginning with /javadev in JDEE classpaths.  The drawback is that
     the conversion is slow as it requires running the cygwin utility
     for each Unix-style path to be converted.

A custom conversion function that you supply.


File: jdee.info,  Node: JDEE Customization Groups,  Prev: Specifying Paths,  Up: JDEE Customization Variables

1.20.1.3 JDEE Customization Groups
..................................

The JDEE defines a top-level customization group, the JDEE Group, for
JDEE customization variables.  The JDEE Group itself contains the
following subgroups:

   _Compile Option Group_

   Specifies compile options corresponding to the command-line arguments
(e.g., -d) accepted by the JDK compiler, javac.  When you execute the
JDEE compile command, the JDEE uses the settings of this group to
construct a list of command-line arguments that it passes to the Java
compiler that the JDEE uses to compile Java source programs.  The
compiler is itself an option that you can specify (see the Project
Option Group).  You can specify command-line arguments directly by
setting the value of the jdee-compile-option-command-line-args variable.
You can display the customization buffer for the Compile Option Group by
selecting JDEE-> Project->Options->Compile from the Emacs™ menubar.

   _Run Option Group_

   Specifies run-time options corresponding to the command-line
arguments (for example, -classpath) accepted by the JDK virtual machine,
java.  When you execute the JDEE Run command, the JDEE uses the settings
of this group to construct a list of command-line arguments that it
passes to the Java interpreter used by the JDEE to run applications.
This group also contains options for specifying non-java command-line
arguments (in case you want to use a VM that accepts a different set of
arguments than java does) and for specifying arguments to be passed to
the application (as opposed to the virtual machine interpreting the
application.)  You can display the customization buffer for the Run
Option Group by selecting JDEE->Project->Options->Run from the Emacs
menubar.

   _Debug Option Group_

   Specifies run-time options corresponding to the command-line
arguments (for example, -classpath) accepted by the JDK debugger, jdb.
jdb accepts the same command-line arguments as java.  However, the JDEE
maintains two parallel sets of configuration variables for these
programs in case you want to use a different set of options for running
a program in debug mode then you use for running it normally.  When you
execute the JDEE Debug command, the JDEE uses the settings of this group
to construct a list of command-line arguments that it passes to the Java
debugger used by the JDEE to run applications in debug mode.  You can
display the customization buffer for the Debug Option Group by selecting
JDEE->Project->Options->Debug from the Emacs™ menubar.

   _Autocode Group_

   Specifies templates used to generate code automatically.

   _General Options Group_

   Specify all other JDEE options.  You can display the customization
buffer for the General Option Group by selecting
JDEE->Project->Options->General from the Emacs menubar.


File: jdee.info,  Node: Customizing jdee-mode,  Prev: JDEE Customization Variables,  Up: Customizing the JDEE

1.20.2 Customizing jdee-mode
----------------------------

The JDEE defines a major mode, named jdee-mode, for editing Java source
files.  This mode derives from the standard Emacs Java source editing
mode java-mode.  In particular, it inherits all the functions and
customization variables defined by java-mode and adds its own
customization variables.  When you load a Java source file, Emacs runs a
JDEE mode initialization function called jdee-mode.  The jdee-mode
function in turn calls the Java mode intialization function, java-mode.
The last thing that jdee-mode does before returning is to call a JDEE
mode function, if it exists.  You can customize the JDEE by defining a
JDEE mode hook function in your .emacs file.  The following is an
example of how to do this:

     (defun my-jdee-mode-hook ()
       (message "my-jdee-mode-hook function executed"))
         (add-hook 'jdee-mode-hook 'my-jdee-mode-hook)

   The preceding example defines a JDEE mode hook function named
my-jdee-mode-hook and adds it to the list of JDEE mode hook functions,
using the Emacs Lisp function add-hook.  Now, whenever you open a Java
source file, jdee-mode invokes the function my-jdee-mode-hook.  Of
course, the hook function defined in this example is trivial.  A
real-world example might do something more useful, such as setting a
custom indentation style.

* Menu:

* Customizing Key Bindings::


File: jdee.info,  Node: Customizing Key Bindings,  Prev: Customizing jdee-mode,  Up: Customizing jdee-mode

1.20.2.1 Customizing Key Bindings
.................................

A key binding establishes an equivalence between a keystroke or a
sequence of keystrokes and an interactive Lisp function.  The keystroke
or keystroke combination causes Emacs to execute the function to which
the keystroke (combination) is bound.  For example, the JDEE by default
binds the keystroke C-c C-v C-c to the function jdee-compile.  You can
use the JDEE customization facility to change the standard JDEE bindings
or create bindings for functions that do not have default bindings.

   To customize key bindings:

  1. Open a buffer on the JDEE customization variable jdee-key-bindings.

     You can do this by typing M-x customize-variable jdee-key-bindings
     or by selecting JDEE->Options->Project and searching the resulting
     JDEE project customization buffer for jdee-key-bindings.

  2. Edit the buffer to specify altered or new bindings.

     For example, to add a binding, right click the [INS] button, then
     enter the key stroke in the Key field and the interactive function
     (command) to which it is bound in the Command field.

  3. Save the edited bindings.

     To save the edited bindings, right click the [State] button and
     choose Set for current session if you want the settings to apply
     only to the current project or Save for future sessionsif you want
     the settings to apply to all projects.  In either case, you should
     save the new settings in you project file if your project has a
     project file.  To save the new settings in your project file,
     switch to a source buffer and choose JDEE-> Options->Save Project
     from the Emacs menubar.


File: jdee.info,  Node: Installing a Plugin,  Prev: Customizing the JDEE,  Up: User's Guide

1.21 Installing a Plugin
========================

To install a plugin:

  1. Copy the zip or jar file containing the plugin in to the JDEE’s
     plugins directory.

     Note: By default the JDEE plugin directory is a subdirectory of the
     JDEE directory named plugins.  If you want to keep your plugins in
     another directory, set jdee-plugins-directory to the path of that
     directory.

  2. Execute M-h jdee-pi-install-plugins.

     This command installs any plugins at the top level of the plugins
     directory in the plugins directory.

   If the plugin adds any menu items to the JDEE’s plugins menu (named
JDEpi), you should now be able to see the items on the plugins menu.


File: jdee.info,  Node: Developer's Guide,  Next: Index,  Prev: User's Guide,  Up: Top

2 Developer’s Guide
*******************

* Menu:

* JDEE Components::             Describes parts of JDEE
* Creating Plugins::


File: jdee.info,  Node: JDEE Components,  Next: Creating Plugins,  Prev: Developer's Guide,  Up: Developer's Guide

2.1 JDEE Components
===================

The JDEE distribution includes the following files:

   • ‘jde.el’ Defines jdee-mode, a major Emacs mode for developing Java
     code.

   • ‘jdee-run.el’ Runs Java applications and applets

   • ‘jdee-db.el’ Interfaces Emacs to jdb, the command-line debugger
     that comes with the JDK.

   • ‘jdee-gen.el’ Contains code generation templates.

   • ‘bsh.jar’ Compiled files for the BeanShell, a Java source code
     interpreter developed by Pat Neimeyer.

   • ‘beanshell.el’ Provides an Emacs interface to the BeanShell
     interpreter.

   • ‘jdee-wiz.el’ Provides "wizards" that generate skeleton
     implementations of interfaces and skeleton overrides of methods
     declared by superclasses.

   • ‘jdee-complete.el’ Automatic field and method completion package.

   • ‘jdee-parse.el’ Java parser package.

   • ‘java.bnf’ Java grammar used to generate the JDEE’s lisp-based Java
     parser.

   • ‘jdee-bug.el’ JDEbug user interface package.

   • ‘jdee-dbs.el’ JDEbug low-level command interface package.

   • ‘jdee-dbo.el’ JDEbug output processing functions.

   • source code, jar files, and documentation for the Java components
     of the JDEE.

   • ‘jtags’ is a bash shell script that tags Java source hierarchies.

   • ‘jtags.csh’ is a c shell script that tags Java source heierarchies.


File: jdee.info,  Node: Creating Plugins,  Prev: JDEE Components,  Up: Developer's Guide

2.2 Creating Plugins
====================

Plugins are independently developed applications intended for use with
the JDEE and distributed in the form of a (g)zip or jar file.  The
following sections explain how to create and install plugins.

   The following sections explain how to create a JDEE plugin.

* Menu:

* Plugin Requirements::
* Registering a Plugin::
* Running Java Code from a Plugin::
* Bootstrap File Example::


File: jdee.info,  Node: Plugin Requirements,  Next: Registering a Plugin,  Prev: Creating Plugins,  Up: Creating Plugins

2.2.1 Plugin Requirements
-------------------------

A JDEE plugin must meet the following requirements:

   _Packaging_

   The plugin must be distributed as a compressed file that can be
decompressed by Java’s jar program.  Compressed file formats that meet
this requirement include zip, gzip, and jar.

   _Directory Structure_

   Decompressing the plugin should create a subdirectory in the current
directory whose name is the plugin’s name and that contains at least one
directory named lisp.  The plugin directory can contain any number of
other directories.  The other directories can have any names.  However,
it would be nice if plugins standardized on the following directory
structure and names.

     plugin
       bsh
        doc
        scripts
       help
         info
         html
         src      (e.g., xml files used to generate info and html)
       java
         class
         doc
         lib      (e.g, jar files)
         src
       lisp

   _Bootstrap File_

   The plugin’s lisp directory must contain a Lisp file named
jdee-PLUGIN.el where PLUGIN is the same as the plugin’s top-level
directory name.  This file is called a bootstrap file because it is the
only file directly loaded by the JDEE. It is responsible for registering
the plugin with the JDEE and loading any other Lisp files required by
the plugin.


File: jdee.info,  Node: Registering a Plugin,  Next: Running Java Code from a Plugin,  Prev: Plugin Requirements,  Up: Creating Plugins

2.2.2 Registering a Plugin
--------------------------

A plugin’s bootstrap file must register the plugin with the JDEE when it
is loaded.  The bootstrap file should do this by invoking the JDEE’s
jdee-pi-register function.  This function takes a single argument: an
instance of jdee-plugin class that optionally specifies the plugin’s
menu and its contribution to the classpath of the instance of the
BeanShell run by the JDEE.


File: jdee.info,  Node: Running Java Code from a Plugin,  Next: Bootstrap File Example,  Prev: Registering a Plugin,  Up: Creating Plugins

2.2.3 Running Java Code from a Plugin
-------------------------------------

A plugin can use the JDEE’s instance of the BeanShell to invoke Java
methods and display their output in an Emacs buffer.  The JDEE provides
the following functions for this purpose:

‘jdee-jeval’
     Evaluate a Java statement in the JDEE’s BeanShell instance and
     return the resulting BeanShell output.

‘jdee-jeval-r’
     Evaluate a Java statement in the JDEE’s BeanShell instance, use the
     Emacs Lisp interpreter to evaluate the resulting BeanShell output,
     and return the result.  This function assumes that the Java
     statement emits Emacs Lisp code, i.e., that the Java code was
     developed specifically to cause Emacs to do something.

‘jdee-jeval-cm’
     Evaluate a Java statement in the JDEE’s BeanShell instance and
     display the resulting BeanShell output in an Emacs compilation
     buffer.  This function is intended to run Java applications, such
     as style checkers, that output error messages keyed to specific
     lines in a source file.

   See the doc strings for these functions for more information.


File: jdee.info,  Node: Bootstrap File Example,  Prev: Running Java Code from a Plugin,  Up: Creating Plugins

2.2.4 Bootstrap File Example
----------------------------

The following is an example of the bootstrap file for a plugin named
‘pi1’.

     ;; jdee-pi1.el
     (defun jdee-pi1-cmd ()
       (interactive)
       (message "plugin 1"))

     (jdee-pi-register
       (jdee-plugin
        "pi1"
        :bsh-cp (list
                  (expand-file-name "lib/lib1.jar" (jdee-pi-get-plugin-dir "pi1"))
                  (expand-file-name "lib/lib2.jar" (jdee-pi-get-plugin-dir "pi1")))
        :menu-spec (list (list "Pi1" ["cmd" jdee-pi1-cmd :active t]))))

     (provide 'jdee-pi1)


File: jdee.info,  Node: Index,  Prev: Developer's Guide,  Up: Top

Index
*****

 [index ]
* Menu:

* chapter, first:                        JDEE Components.       (line 6)



Tag Table:
Node: Top69
Node: User's Guide5401
Node: Introduction6322
Node: About6581
Node: JDEE Requirements7927
Node: Latest Version8658
Node: Installing the JDEE8933
Node: Reporting bugs9206
Node: Registering and Selecting a JDK9480
Node: Registering a JDK10938
Node: Selecting a JDK11727
Node: Editing Java Source Files12610
Node: Documenting Code13463
Node: Inserting Javadoc Comments13893
Node: Generating the Documentation14484
Node: Abbreviations15616
Node: Keyword Abbreviations15989
Node: Control Flow Abbreviations17067
Node: Left Brace Placement19216
Node: Customizing the Control Flow Templates19727
Node: Adding Your Own Control Flow Templates20144
Node: Enabling Variable Content23349
Node: Disabling the Control Flow Abbreviations23774
Node: Completing Expressions24096
Node: Completing Method and Field Names24863
Node: Selecting a Completion Method28987
Node: Using Menu-Based Completion29964
Node: Using In-Line Completion30792
Node: Speeding Up Completion32129
Node: Dynamic Keyword Completion33233
Node: Dynamic Completion Commands34027
Node: Electric Return34806
Node: Generating Code35258
Node: Generating Import Statements35597
Node: Importing Classes36465
Node: Importing All Classes38902
Node: Expanding Package Imports40145
Node: Collapsing Class Imports40783
Node: Grouping Imports41685
Node: Deleting Unneeded Imports43967
Node: Code Wizards44428
Node: Method Override Wizard45484
Node: Interface Wizard48174
Node: Delegate Wizard49925
Node: Get/Set Wizard50533
Node: Code Templates51118
Node: Buffer Templates51542
Node: Specifying Boilerplate Text52535
Node: Code Templates Customization Variables53635
Node: Point Templates55733
Node: Customizing Templates57930
Node: Creating Templates59381
Node: Defining a Template and Template Insertion Function60812
Node: Registering Custom Templates63734
Node: Assigning Keys to Templates64804
Node: Checking Coding Style65271
Node: Compiling Java Programs65868
Node: Compilation Buffer66634
Node: Specifying a Compiler67342
Node: Compilation Options69569
Node: Setting Compile Options Interactively70252
Node: Compiler Customization Variables71541
Node: Building Java Applications75888
Node: Selecting a Build Method76407
Node: Building with Make77181
Node: Make Options78005
Node: Sample Makefile79903
Node: Building with Ant80879
Node: Running Java Applications87061
Node: Specifying the Application's Main Class88141
Node: Specifying a Startup Directory89241
Node: Setting VM Command-Line Arguments90811
Node: Setting Command-Line Application Arguments91510
Node: Navigating Exception Traces92535
Node: Run Customization Variables93192
Node: Working with Applets98686
Node: Running Applets99033
Node: Debugging Applets100700
Node: Applet Customization Variables101867
Node: Debugging Applications103336
Node: Specifying Classpaths103996
Node: Setting a Classpath Variable105256
Node: Including Class Libraries106516
Node: Using Project Files108192
Node: How the JDEE Finds Project Files109131
Node: Project File Contents110676
Node: Creating a Project File111301
Node: Creating Portable Projects113102
Node: Disabling Context Switching114147
Node: Project Hook Functions115410
Node: Displaying Java Documentation115833
Node: Browsing JDK Documentation116245
Node: Context-Sensitive Class Help116804
Node: Specifying a Browser117546
Node: Using emacs-w3m to Browse Java Doc117945
Node: Browsing Source Code119097
Node: Classes Index Menu119350
Node: Special Index Entries120599
Node: Alphabetizing the Classes Menu121259
Node: Suppressing Method Signatures and Field Types121754
Node: Disabling the Classes Menu122412
Node: Using the Keyboard to Navigate the Classes Menu122805
Node: Using the Speedbar123589
Node: Package124286
Node: Types124577
Node: Dependencies125200
Node: Updating the Speedbar125533
Node: Tags126192
Node: Tagging Java Source Code126686
Node: Finding the Definition of a Symbol127276
Node: Searching Source Code127770
Node: Finding Expressions128640
Node: Using the Minibuffer-Based Find (jdee-find) Command131042
Node: Customizing the Minibuffer-Based Find Command132854
Node: Using the Dialog-Based Find (jdee-find-dlg) Command134521
Node: Finding Symbol Definitions135332
Node: Finding Classes136191
Node: Cross-Referencing Classes137303
Node: Configuring the Cross-Referencer138353
Node: Building the Cross-Reference Database140464
Node: Using the Cross-Reference Database141455
Node: Updating the Cross-Reference Database144066
Node: Customizing the JDEE144868
Node: JDEE Customization Variables145180
Node: Setting a Customization Variable146360
Node: Specifying Paths149359
Node: JDEE Customization Groups152262
Node: Customizing jdee-mode155199
Node: Customizing Key Bindings156707
Node: Installing a Plugin158504
Node: Developer's Guide159300
Node: JDEE Components159520
Node: Creating Plugins161089
Node: Plugin Requirements161611
Node: Registering a Plugin163088
Node: Running Java Code from a Plugin163663
Node: Bootstrap File Example164953
Node: Index165650

End Tag Table


Local Variables:
coding: utf-8
End:
